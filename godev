#!/bin/zsh
#
# -----------------------------------------------------------------------------
# Welcome to godev!
#
# This software is free and open source.
# Feel free to use, modify, and share it as you wish.
#
# (See full Apache 2.0 License at the end of this file)
# -----------------------------------------------------------------------------
#
# godev - Multi-Folder Development Tree Demystification Tool
#
# DESCRIPTION
#   Demystify your multi-folder development tree. Navigate projects instantly,
#   see Git activity at a glance, and make sense of complex development structures.
#
# REQUIREMENTS
#   This script REQUIRES ZSH (Z Shell) and will NOT work with Bash.
#   It uses ZSH-specific features such as:
#   - Array indexing and parameter expansion flags
#   - Advanced parameter substitution
#   - ZSH-specific array operations
#
# USAGE
#   godev <command> [options]
#
# COMMANDS
#   nav, n <pattern>     Navigate to project (default command)
#   status, s [options]   Show project activity status
#   list, l              List all projects
#   ai-status            Check AI development tools status
#   version, v           Show version
#   help, h              Show help
#
# EXAMPLES
#   godev nav react          # Navigate to react project
#   godev react              # Same (nav is default)
#   godev status             # Show all project statuses
#   godev status -f 7        # Show active in last 7 days
#   godev list               # List all projects
#   godev ai-status          # Check AI tools
# -----------------------------------------------------------------------------

VERSION="2.0.0"
BUILD="45"  # Auto-incremented on each commit

# Detect if output is to a terminal
if [[ -t 1 ]]; then
    # Colors for output (only if terminal)
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    MAGENTA='\033[0;35m'
    CYAN='\033[0;36m'
    WHITE='\033[1;37m'
    GRAY='\033[0;90m'
    NC='\033[0m' # No Color
else
    # No colors if not a terminal
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    MAGENTA=''
    CYAN=''
    WHITE=''
    GRAY=''
    NC=''
fi

# Base projects directory (adjust according to your configuration)
DEV_BASE="${HOME}/DEV"

# Configuration
MAX_DEPTH=5  # Maximum depth for recursive search (0 = unlimited)
READONLY_MODE=true  # Set to false to allow directory creation (for testing)

# Show help
show_help() {
    echo -e "${WHITE}godev${NC} - Multi-Folder Development Tree Demystification Tool"
    echo ""
    echo -e "${CYAN}USAGE:${NC}"
    echo "    godev <command> [options]"
    echo ""
    echo -e "${CYAN}COMMANDS:${NC}"
    echo -e "    ${GREEN}nav, n${NC} <pattern>        Navigate to project (default command)"
    echo -e "    ${GREEN}status, s${NC} [options]     Show project activity status"
    echo -e "    ${GREEN}list, l${NC}                 List all projects"
    echo -e "    ${GREEN}ai-status${NC}               Check AI development tools status"
    echo -e "    ${GREEN}version, v${NC}              Show version"
    echo -e "    ${GREEN}help, h${NC}                 Show this help"
    echo ""
    echo -e "${CYAN}NAV OPTIONS:${NC}"
    echo "    -f, --force              Force directory creation"
    echo -e "                           ${GRAY}(Not available in readonly mode)${NC}"
    echo ""
    echo -e "${CYAN}STATUS OPTIONS:${NC}"
    echo "    -d, --dir <path>         Base directory to scan (default: ~/DEV)"
    echo "    -s, --sort <mode>        Sort mode: date|name|activity (default: date)"
    echo "    -f, --filter <days>      Show only projects active in last N days"
    echo "    -a, --all                Show all projects, including non-Git directories"
    echo ""
    echo -e "${CYAN}EXAMPLES:${NC}"
    echo "    godev nav react          # Navigate to react project"
    echo "    godev react              # Same (nav is default)"
    echo "    godev status             # Show all project statuses"
    echo "    godev status -f 7        # Show active in last 7 days"
    echo "    godev status -a          # Show all projects including non-Git"
    echo "    godev list               # List all projects"
    echo "    godev ai-status          # Check AI tools"
    echo ""
    echo -e "${CYAN}READONLY MODE:${NC}"
    echo -e "    This tool works in ${YELLOW}readonly mode${NC} by default."
    echo -e "    In readonly mode, directory creation (${GREEN}-f${NC}) is disabled."
    echo ""
    echo -e "    ${GRAY}To change readonly mode:${NC}"
    echo -e "    1. Edit the ${GREEN}godev${NC} script"
    echo -e "    2. Find: ${GREEN}READONLY_MODE=true${NC}"
    echo -e "    3. Change to: ${GREEN}READONLY_MODE=false${NC}"
    echo -e "    4. Save and restart your terminal"
    echo ""
    echo -e "${CYAN}FZF INTEGRATION:${NC}"
    echo -e "    godev uses ${GREEN}fzf${NC} for interactive selection when multiple matches are found."
    echo -e "    If ${GREEN}fzf${NC} is not available, a numbered list will be shown instead."
    echo ""
    echo -e "    ${GRAY}To disable fzf (for testing):${NC}"
    echo -e "    ${GREEN}GODEV_NO_FZF=1 godev nav <pattern>${NC}"
    echo ""
    echo -e "    ${GRAY}Note:${NC} The script validates:"
    echo -e "    - fzf availability (checks if command exists)"
    echo -e "    - Temporary directory write permissions"
    echo -e "    If either check fails, the numbered list fallback is used automatically."
}

# Main command dispatcher
main() {
    local command="$1"
    shift
    
    # If no command provided, default to nav (for backward compatibility)
    if [[ -z "$command" ]]; then
        # No command - show help
        show_help
        exit 0
    fi
    
    # Check if it's a flag first
    if [[ "$command" == -* ]]; then
        case "$command" in
            -v|--version)
                echo "godev version $VERSION+build.$BUILD"
                exit 0
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                echo -e "${RED}Unknown option: $command${NC}" >&2
                echo "Run 'godev help' for usage"
                exit 1
                ;;
        esac
    fi
    
    # If command is not a known command, treat as nav pattern
    if [[ "$command" != "nav" ]] && [[ "$command" != "n" ]] && \
       [[ "$command" != "status" ]] && [[ "$command" != "s" ]] && \
       [[ "$command" != "list" ]] && [[ "$command" != "l" ]] && \
       [[ "$command" != "ai-status" ]] && [[ "$command" != "ai" ]] && \
       [[ "$command" != "help" ]] && [[ "$command" != "h" ]] && \
       [[ "$command" != "version" ]] && [[ "$command" != "v" ]]; then
        # Treat as nav pattern (default behavior)
        nav_command "$command" "$@"
        return
    fi
    
    case "$command" in
        nav|n|"")
            nav_command "$@"
            ;;
        status|s|stats)
            status_command "$@"
            ;;
        list|l)
            list_command "$@"
            ;;
        ai-status|ai)
            ai_status_command "$@"
            ;;
        version|v)
            echo "godev version $VERSION+build.$BUILD"
            ;;
        help|h)
            show_help
            ;;
        *)
            echo -e "${RED}Unknown command: $command${NC}" >&2
            echo "Run 'godev help' for usage"
            exit 1
            ;;
    esac
}

# Navigation command (migrated from godev.sh)
nav_command() {
    local pattern=""
    local force_create=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -f|--force)
                force_create=true
                shift
                ;;
            -v|--version)
                echo "godev version $VERSION+build.$BUILD"
                return 0
                ;;
            -h|--help)
                echo "godev nav - Navigate to development project"
                echo ""
                echo "Usage: godev nav <pattern> [-f]"
                echo ""
                echo "Options:"
                echo "  <pattern>       Directory search pattern"
                echo "  -f, --force     Force directory creation (disabled in readonly mode)"
                echo "  -h, --help      Show this help"
                return 0
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}" >&2
                echo "Use 'godev nav -h' to see help"
                return 1
                ;;
            *)
                pattern="$1"
                shift
                ;;
        esac
    done
    
    # Verify that the base directory exists
    if [[ ! -d "$DEV_BASE" ]]; then
        echo -e "${RED}Error: Base directory $DEV_BASE does not exist${NC}" >&2
        return 1
    fi
    
    # Verify that a pattern was provided
    if [[ -z "$pattern" ]]; then
        echo -e "${YELLOW}Usage: godev nav <pattern> [-f]${NC}"
        echo "  -f, --force     Force directory creation"
        echo "  -h, --help      Show full help"
        return 1
    fi
    
    # Search for directories matching the pattern
    # Exclude: node_modules, .git, .github, dist, build, vendor, .next, etc.
    local matches=()
    while IFS= read -r -d '' dir; do
        # Additional filter: exclude directories that are .git, .github, or other config dirs
        local dirname=$(basename "$dir")
        if [[ "$dirname" == ".git" ]] || [[ "$dirname" == ".github" ]]; then
            continue
        fi
        matches+=("$dir")
    done < <(find "$DEV_BASE" -maxdepth 3 -type d \
        -not -path "*/node_modules/*" \
        -not -path "*/.git/*" \
        -not -name ".git" \
        -not -path "*/.github/*" \
        -not -name ".github" \
        -not -path "*/dist/*" \
        -not -path "*/build/*" \
        -not -path "*/vendor/*" \
        -not -path "*/.next/*" \
        -not -path "*/target/*" \
        -not -path "*/__pycache__/*" \
        -not -path "*/.venv/*" \
        -iname "*${pattern}*" -print0 2>/dev/null)
    
    local count=${#matches[@]}
    
    if [[ $count -eq 0 ]]; then
        # No matches found
        if [[ "$force_create" == true ]]; then
            if [[ "$READONLY_MODE" == true ]]; then
                echo -e "${YELLOW}[READONLY MODE]${NC} Would create directory: ${DEV_BASE}/${pattern}"
                echo "To actually create it, set READONLY_MODE=false in the script"
                return 0
            else
                local new_dir="${DEV_BASE}/${pattern}"
                mkdir -p "$new_dir"
                echo -e "${GREEN}‚úì${NC} Directory created: $new_dir"
                if [[ -n "$ZSH_VERSION" ]]; then
                    # In ZSH, we can't change directory from a script
                    # User needs to source it or we output the path
                    echo "Path: $new_dir"
                    echo "Run: cd $new_dir"
                fi
                return 0
            fi
        else
            echo -e "${YELLOW}No directory found matching pattern: $pattern${NC}"
            echo "Use 'godev nav $pattern -f' to create the directory"
            return 1
        fi
    elif [[ $count -eq 1 ]]; then
        # Single match - show directory
        local target_dir="${matches[1]}"
        echo -e "${GREEN}‚Üí${NC} ${target_dir}"
        # Always output path in consistent format for function wrapper
        # Note: READONLY_MODE only prevents directory creation, not navigation
        echo "Path: $target_dir"
        # Also write to temp file for function wrapper (works when output is captured)
        # Only if we have write permissions to temp directory
        local tmp_dir="${TMPDIR:-/tmp}"
        if [[ -w "$tmp_dir" ]]; then
            local path_file="${tmp_dir}/godev_selected_path_$$"
            echo "$target_dir" > "$path_file" 2>/dev/null || true
        fi
        return 0
    else
        # Multiple matches - use fzf if available, otherwise show numbered list
        local target_dir=""
        
        # Check if fzf should be disabled via environment variable
        local use_fzf=true
        if [[ -n "${GODEV_NO_FZF:-}" ]]; then
            use_fzf=false
        fi
        
        # Validate temporary directory permissions
        local tmp_dir="${TMPDIR:-/tmp}"
        local can_write_tmp=false
        if [[ -w "$tmp_dir" ]]; then
            can_write_tmp=true
        else
            echo -e "${YELLOW}Warning: Cannot write to temporary directory ($tmp_dir)${NC}" >&2
            echo -e "${GRAY}Some features may be limited. Falling back to numbered list selection.${NC}" >&2
            use_fzf=false
        fi
        
        # Check if fzf is available and should be used
        if [[ "$use_fzf" == true ]] && command -v fzf >/dev/null 2>&1; then
            # Use fzf for interactive selection
            local rel_paths=()
            for dir in "${matches[@]}"; do
                rel_paths+=("${dir#$DEV_BASE/}|$dir")
            done
            
            # Use fzf to select, showing relative paths but returning full path
            local selected=$(printf '%s\n' "${rel_paths[@]}" | \
                sed 's/|.*$//' | \
                fzf --height=40% --border --header="Select a directory (${count} matches):" \
                    --preview="echo {}" --preview-window=down:1 2>/dev/tty)
            
            if [[ -n "$selected" ]]; then
                # Find the full path for the selected relative path
                for dir in "${matches[@]}"; do
                    local rel_path="${dir#$DEV_BASE/}"
                    if [[ "$rel_path" == "$selected" ]]; then
                        target_dir="$dir"
                        break
                    fi
                done
            else
                echo "Cancelled" >&2
                return 1
            fi
        else
            # Fallback to numbered list selection (fzf not available or disabled)
            if [[ "$use_fzf" == false ]] && [[ -n "${GODEV_NO_FZF:-}" ]]; then
                echo -e "${GRAY}[fzf disabled via GODEV_NO_FZF]${NC}" >&2
            elif [[ "$use_fzf" == false ]] && [[ "$can_write_tmp" == false ]]; then
                echo -e "${GRAY}[fzf disabled: no temp directory write access]${NC}" >&2
            elif ! command -v fzf >/dev/null 2>&1; then
                echo -e "${GRAY}[fzf not available]${NC}" >&2
            fi
            echo -e "${CYAN}Found $count directories:${NC}" >&2
            echo "" >&2
            local i=1
            for dir in "${matches[@]}"; do
                local rel_path="${dir#$DEV_BASE/}"
                echo -e "  ${GREEN}[$i]${NC} ${rel_path}" >&2
                ((i++))
            done
            echo "" >&2
            
            # Write prompt to stderr so it's visible even when output is captured
            if [[ "$READONLY_MODE" == true ]]; then
                echo -e "${GRAY}[READONLY MODE]${NC} Select a number (1-$count) to see path, or press Enter to cancel: " >&2
            else
                echo -n "Select a number (1-$count) or press Enter to cancel: " >&2
            fi
            
            # Read from terminal - try /dev/tty first, fallback to stdin
            if [[ -r /dev/tty ]]; then
                read selection < /dev/tty
            else
                read selection
            fi
            
            if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -le $count ]]; then
                target_dir="${matches[$selection]}"
            else
                echo "Cancelled" >&2
                return 1
            fi
        fi
        
        # Output selected directory
        if [[ -n "$target_dir" ]]; then
            echo -e "${GREEN}‚Üí${NC} ${target_dir}"
            # Always output path in consistent format for function wrapper
            echo "Path: $target_dir"
            # Also write to temp file for function wrapper (works when output is captured)
            # Only if we have write permissions to temp directory
            local tmp_dir="${TMPDIR:-/tmp}"
            if [[ -w "$tmp_dir" ]]; then
                local path_file="${tmp_dir}/godev_selected_path_$$"
                echo "$target_dir" > "$path_file" 2>/dev/null || true
            fi
            return 0
        else
            return 1
        fi
    fi
}

# Status command (migrated from govap.sh)
status_command() {
    local SHOW_ALL=false
    local SORT_MODE="date"
    local FILTER_DAYS=""
    local status_dev_base="$DEV_BASE"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d|--dir)
                status_dev_base="$2"
                shift 2
                ;;
            -s|--sort)
                SORT_MODE="$2"
                shift 2
                ;;
            -f|--filter)
                FILTER_DAYS="$2"
                shift 2
                ;;
            -a|--all)
                SHOW_ALL=true
                shift
                ;;
            -h|--help)
                echo "godev status - Show project activity status"
                echo ""
                echo "Usage: godev status [options]"
                echo ""
                echo "Options:"
                echo "  -d, --dir <path>      Base directory to scan (default: ~/DEV)"
                echo "  -s, --sort <mode>     Sort mode: date|name|activity (default: date)"
                echo "  -f, --filter <days>   Show only projects active in last N days"
                echo "  -a, --all             Show all projects, including non-Git directories"
                echo "  -h, --help            Show this help"
                return 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}" >&2
                echo "Use 'godev status -h' for help"
                return 1
                ;;
        esac
    done
    
    # Verify that the base directory exists
    if [[ ! -d "$status_dev_base" ]]; then
        echo -e "${RED}Error: Base directory $status_dev_base does not exist${NC}" >&2
        return 1
    fi
    
    echo -e "${WHITE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${WHITE}  üîç Project Activity Status${NC}"
    echo -e "${WHITE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${GRAY}Scanning: ${status_dev_base}${NC}"
    echo ""
    
    # Collect project information
    local projects=()
    local project_count=0
    local git_count=0
    
    # Find all directories containing .git recursively
    local find_args=("$status_dev_base")
    if [[ $MAX_DEPTH -gt 0 ]]; then
        find_args+=("-maxdepth" "$MAX_DEPTH")
    fi
    find_args+=(
        "-type" "d" "-name" ".git"
        "-not" "-path" "*/node_modules/*"
        "-not" "-path" "*/dist/*"
        "-not" "-path" "*/build/*"
        "-not" "-path" "*/vendor/*"
        "-not" "-path" "*/.next/*"
        "-not" "-path" "*/target/*"
        "-not" "-path" "*/__pycache__/*"
        "-not" "-path" "*/.venv/*"
        "-print"
    )
    
    while IFS= read -r git_dir; do
        local dir=$(dirname "$git_dir")
        if [[ -d "$dir" ]]; then
            local info=$(get_project_info "$dir" "$status_dev_base" "$SHOW_ALL")
            if [[ -n "$info" ]]; then
                projects+=("$info")
                ((project_count++))
                if [[ "$info" != *"NO_GIT"* ]]; then
                    ((git_count++))
                fi
            fi
        fi
    done < <(find "${find_args[@]}" 2>/dev/null)
    
    # If SHOW_ALL is true, also include non-Git directories at first level
    if [[ "$SHOW_ALL" == true ]]; then
        for dir in "$status_dev_base"/*/; do
            if [[ -d "$dir" ]] && [[ ! -d "$dir/.git" ]]; then
                local info=$(get_project_info "$dir" "$status_dev_base" "$SHOW_ALL")
                if [[ -n "$info" ]] && [[ "$info" == *"NO_GIT"* ]]; then
                    projects+=("$info")
                    ((project_count++))
                fi
            fi
        done
    fi
    
    if [[ $project_count -eq 0 ]]; then
        echo -e "${YELLOW}No projects found in $status_dev_base${NC}"
        return 0
    fi
    
    # Filter by days if specified
    if [[ -n "$FILTER_DAYS" ]]; then
        local filtered=()
        for project in "${projects[@]}"; do
            local fields=("${(@s:|:)project}")
            local timestamp="${fields[4]}"
            local days=$(days_since_commit "$timestamp")
            if [[ $days -le $FILTER_DAYS ]]; then
                filtered+=("$project")
            fi
        done
        projects=("${filtered[@]}")
    fi
    
    # Sort projects
    case "$SORT_MODE" in
        name)
            local sorted=()
            while IFS= read -r line; do
                sorted+=("$line")
            done < <(printf '%s\n' "${projects[@]}" | sort -t'|' -k1)
            projects=("${sorted[@]}")
            ;;
        activity)
            local sorted=()
            while IFS= read -r line; do
                sorted+=("$line")
            done < <(printf '%s\n' "${projects[@]}" | sort -t'|' -k7 -rn)
            projects=("${sorted[@]}")
            ;;
        date|*)
            local sorted=()
            while IFS= read -r line; do
                sorted+=("$line")
            done < <(printf '%s\n' "${projects[@]}" | sort -t'|' -k4 -rn)
            projects=("${sorted[@]}")
            ;;
    esac
    
    # Display results
    local active_count=0
    local modified_count=0
    local ahead_count=0
    local behind_count=0
    
    printf "%-30s %-20s %-15s %-12s %s\n" \
        "PROJECT" "LAST COMMIT" "BRANCH" "STATUS" "ACTIVITY (30d)"
    echo -e "${GRAY}$(printf '%.0s‚îÄ' {1..100})${NC}"
    
    for project in "${projects[@]}"; do
        local fields=("${(@s:|:)project}")
        local name="${fields[1]}"
        local rel="${fields[2]}"
        local abs="${fields[3]}"
        local timestamp="${fields[4]}"
        local branch="${fields[5]}"
        local repo_status="${fields[6]}"
        local commits="${fields[7]}"
        local total="${fields[8]}"
        
        # Skip if no git and not showing all
        if [[ "$repo_status" == "NO_GIT" ]] && [[ "$SHOW_ALL" != true ]]; then
            continue
        fi
        
        # Truncate long names
        local display_name="$name"
        if [[ ${#display_name} -gt 28 ]]; then
            display_name="${display_name:0:25}..."
        fi
        
        # Format branch
        local display_branch="$branch"
        if [[ ${#display_branch} -gt 13 ]]; then
            display_branch="${display_branch:0:10}..."
        fi
        
        # Format relative date
        local display_date="$rel"
        if [[ ${#display_date} -gt 18 ]]; then
            display_date="${display_date:0:15}..."
        fi
        
        # Status icon and color
        local status_display=$(format_status "$repo_status")
        
        # Activity indicator
        local activity_display=""
        if [[ "$commits" != "N/A" ]] && [[ "$commits" != "" ]] && [[ "$commits" =~ ^[0-9]+$ ]]; then
            if [[ $commits -gt 10 ]]; then
                activity_display="${GREEN}‚óè‚óè‚óè${NC} ($commits)"
            elif [[ $commits -gt 5 ]]; then
                activity_display="${YELLOW}‚óè‚óè‚óã${NC} ($commits)"
            elif [[ $commits -gt 0 ]]; then
                activity_display="${GRAY}‚óè‚óã‚óã${NC} ($commits)"
            else
                activity_display="${GRAY}‚óã‚óã‚óã${NC} (0)"
            fi
        else
            activity_display="${GRAY}‚óã‚óã‚óã${NC}"
        fi
        
        # Calculate real widths (without ANSI codes) for proper alignment
        local status_plain=$(strip_ansi "$status_display")
        
        local name_width=${#display_name}
        local date_width=${#display_date}
        local branch_width=${#display_branch}
        local status_width=${#status_plain}
        
        # Column widths match the header: 30, 20, 15, 12
        local name_pad=$((30 - name_width))
        local date_pad=$((20 - date_width))
        local branch_pad=$((15 - branch_width))
        local status_pad=$((12 - status_width))
        
        # Build the output line with proper padding
        local output_line=""
        output_line+="$(printf '%-30s' "$display_name")"
        output_line+="$(printf '%-20s' "$display_date")"
        output_line+="$(printf '%-15s' "$display_branch")"
        output_line+="$status_display"
        if [[ $status_pad -gt 0 ]]; then
            output_line+="$(printf '%*s' $status_pad '')"
        fi
        output_line+=" $activity_display"
        
        # Print with echo -e to interpret ANSI codes
        echo -e "$output_line"
        
        # Count statistics
        case "$repo_status" in
            clean|ahead|behind|diverged)
                ((active_count++))
                ;;
            modified)
                ((modified_count++))
                ((active_count++))
                ;;
        esac
        
        if [[ "$repo_status" == "ahead" ]] || [[ "$repo_status" == "diverged" ]]; then
            ((ahead_count++))
        fi
        if [[ "$repo_status" == "behind" ]] || [[ "$repo_status" == "diverged" ]]; then
            ((behind_count++))
        fi
    done
    
    echo ""
    echo -e "${WHITE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${GRAY}Summary:${NC}"
    echo -e "  Total projects: ${WHITE}$project_count${NC}"
    echo -e "  Git repositories: ${WHITE}$git_count${NC}"
    echo -e "  Active repos: ${GREEN}$active_count${NC}"
    if [[ $modified_count -gt 0 ]]; then
        echo -e "  Modified: ${YELLOW}$modified_count${NC}"
    fi
    if [[ $ahead_count -gt 0 ]]; then
        echo -e "  Ahead of remote: ${YELLOW}$ahead_count${NC}"
    fi
    if [[ $behind_count -gt 0 ]]; then
        echo -e "  Behind remote: ${BLUE}$behind_count${NC}"
    fi
    echo -e "${WHITE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
}

# Helper functions for status command
get_project_info() {
    local dir="$1"
    local dev_base="${2:-$DEV_BASE}"
    local show_all="${3:-false}"
    # Remove trailing slash and get relative path from DEV_BASE
    local dir_clean="${dir%/}"
    # Get relative path from DEV_BASE to show nested structure
    local dev_base_clean="${dev_base%/}"
    local project_name="${dir_clean#$dev_base_clean/}"
    # If project_name is empty or same as dir, fallback to directory name
    if [[ -z "$project_name" ]] || [[ "$project_name" == "$dir_clean" ]]; then
        project_name="${dir_clean##*/}"
    fi
    
    if [[ ! -d "$dir/.git" ]]; then
        if [[ "$show_all" == true ]]; then
            echo "$project_name|NO_GIT|N/A|N/A|N/A|N/A|N/A|N/A"
        fi
        return
    fi
    
    pushd "$dir" > /dev/null 2>&1 || return
    
    # Get last commit date (relative and absolute)
    local last_commit_relative=""
    local last_commit_absolute=""
    local last_commit_timestamp=""
    
    if git rev-parse --git-dir > /dev/null 2>&1; then
        last_commit_relative=$(git log -1 --format="%ar" 2>/dev/null)
        last_commit_absolute=$(git log -1 --format="%ci" 2>/dev/null)
        last_commit_timestamp=$(git log -1 --format="%ct" 2>/dev/null)
        
        # Get current branch
        local branch=$(git branch --show-current 2>/dev/null || echo "detached")
        
        # Get repository status
        local repo_status=""
        local git_status=$(git status --porcelain 2>/dev/null)
        local ahead=$(git status -sb 2>/dev/null | grep -o 'ahead [0-9]*' | grep -o '[0-9]*')
        local behind=$(git status -sb 2>/dev/null | grep -o 'behind [0-9]*' | grep -o '[0-9]*')
        
        if [[ -n "$git_status" ]]; then
            repo_status="modified"
        elif [[ -n "$ahead" ]] && [[ -n "$behind" ]]; then
            repo_status="diverged"
        elif [[ -n "$ahead" ]]; then
            repo_status="ahead"
        elif [[ -n "$behind" ]]; then
            repo_status="behind"
        else
            repo_status="clean"
        fi
        
        # Get commit count (last 30 days)
        local commit_count=$(git log --since="30 days ago" --oneline 2>/dev/null | wc -l | tr -d ' ')
        
        # Get total commits
        local total_commits=$(git rev-list --count HEAD 2>/dev/null || echo "0")
        
        echo "$project_name|$last_commit_relative|$last_commit_absolute|$last_commit_timestamp|$branch|$repo_status|$commit_count|$total_commits"
    fi
    
    popd > /dev/null 2>&1
}

days_since_commit() {
    local timestamp="$1"
    if [[ -z "$timestamp" ]] || [[ "$timestamp" == "N/A" ]]; then
        echo "999999"
        return
    fi
    local now=$(date +%s)
    local diff=$((now - timestamp))
    echo $((diff / 86400))
}

strip_ansi() {
    echo "$1" | sed 's/\x1b\[[0-9;]*m//g'
}

format_status() {
    local repo_status="$1"
    case "$repo_status" in
        clean)
            echo -e "${GREEN}‚úì clean${NC}"
            ;;
        modified)
            echo -e "${RED}‚óè modified${NC}"
            ;;
        ahead)
            echo -e "${YELLOW}‚Üë ahead${NC}"
            ;;
        behind)
            echo -e "${BLUE}‚Üì behind${NC}"
            ;;
        diverged)
            echo -e "${MAGENTA}‚Üï diverged${NC}"
            ;;
        NO_GIT)
            echo -e "${GRAY}‚óã no git${NC}"
            ;;
        *)
            echo -e "${GRAY}$repo_status${NC}"
            ;;
    esac
}

list_command() {
    echo -e "${YELLOW}Command 'list' is being implemented...${NC}"
    echo "This will list all projects."
}

ai_status_command() {
    echo -e "${YELLOW}Command 'ai-status' is being implemented...${NC}"
    echo "This will check AI development tools status."
}

# Run main function
main "$@"

# -----------------------------------------------------------------------------
# LICENSE (Apache 2.0)
#
# Copyright 2024 Augusto Sosa Escalada
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# -----------------------------------------------------------------------------

