#!/bin/zsh
#
# -----------------------------------------------------------------------------
# Welcome to godev!
#
# This software is free and open source.
# Feel free to use, modify, and share it as you wish.
#
# (See full Apache 2.0 License at the end of this file)
# -----------------------------------------------------------------------------
#
# godev - Multi-Folder Development Tree Demystification Tool
#
# DESCRIPTION
#   Demystify your multi-folder development tree. Navigate projects instantly,
#   see Git activity at a glance, and make sense of complex development structures.
#
# REQUIREMENTS
#   This script REQUIRES ZSH (Z Shell) and will NOT work with Bash.
#   It uses ZSH-specific features such as:
#   - Array indexing and parameter expansion flags
#   - Advanced parameter substitution
#   - ZSH-specific array operations
#
# USAGE
#   godev <command> [options]
#
# COMMANDS
#   nav, n <pattern>     Navigate to project (default command)
#   status, s [options]   Show project activity status
#   list, l              List all projects
#   ai-status            Check AI development tools status
#   version, v           Show version
#   help, h              Show help
#
# EXAMPLES
#   godev nav react          # Navigate to react project
#   godev react              # Same (nav is default)
#   godev status             # Show all project statuses
#   godev status -f 7        # Show active in last 7 days
#   godev list               # List all projects
#   godev ai-status          # Check AI tools
# -----------------------------------------------------------------------------

VERSION="2.0.0"
BUILD="71"  # Auto-incremented on each commit

# Detect if output is to a terminal
if [[ -t 1 ]]; then
    # Colors for output (only if terminal)
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    MAGENTA='\033[0;35m'
    CYAN='\033[0;36m'
    WHITE='\033[1;37m'
    GRAY='\033[0;90m'
    NC='\033[0m' # No Color
else
    # No colors if not a terminal
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    MAGENTA=''
    CYAN=''
    WHITE=''
    GRAY=''
    NC=''
fi

# Configuration file location
CONFIG_DIR="${HOME}/.config/godev"
CONFIG_FILE="${CONFIG_DIR}/config"

# Base projects directory (adjust according to your configuration)
# Can be overridden by config file or first-run setup
DEV_BASE="${HOME}/DEV"

# Configuration
MAX_DEPTH=5  # Maximum depth for recursive search (0 = unlimited)
READONLY_MODE=true  # Set to false to allow directory creation (for testing)

# Load configuration if it exists
if [[ -f "$CONFIG_FILE" ]]; then
    source "$CONFIG_FILE"
fi

# Prompt helpers --------------------------------------------------------------
# Some shells/functions wrap godev and capture stdout, so stdout might not be a
# TTY even though the user is interactive. These helpers fall back to /dev/tty
# so we can always ask questions during setup.
can_prompt() {
    [[ -t 0 || -t 1 || -r /dev/tty ]]
}

prompt_input() {
    local __prompt="$1"
    local __out_var="$2"
    local __input=""

    if [[ -t 0 ]] || [[ -t 1 ]]; then
        IFS= read -r "__input?${__prompt}"
    elif [[ -r /dev/tty ]]; then
        IFS= read -r "__input?${__prompt}" < /dev/tty
    else
        return 1
    fi

    typeset -g "$__out_var"="$__input"
    return 0
}

# First-run configuration wizard
first_run_setup() {
    # Check if already configured
    if [[ -f "$CONFIG_FILE" ]]; then
        # Configuration already exists, skip setup
        return 0
    fi
    
    # Only run setup if interactive
    if [[ ! -t 0 ]] || [[ ! -t 1 ]]; then
        # Non-interactive: use defaults
        return 0
    fi
    
    echo ""
    echo -e "${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${CYAN}‚ïë${NC}  ${CYAN}‚öôÔ∏è  First-time Setup${NC}                                      ${CYAN}‚ïë${NC}"
    echo -e "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
    echo -e "${GRAY}Welcome to godev! Let's configure it for the first time.${NC}"
    echo ""
    
    # Ask about base directory
    DEFAULT_DEV_BASE="${HOME}/DEV"
    echo -e "${CYAN}Base directory configuration:${NC}"
    echo -e "  This is where godev will search for your projects"
    echo ""
    read "?Base directory for projects (default: $DEFAULT_DEV_BASE): " custom_dev_base
    
    # Expand ~ and variables in user input
    if [[ -n "$custom_dev_base" ]]; then
        custom_dev_base="${custom_dev_base/#\~/$HOME}"
        DEV_BASE=$(eval echo "$custom_dev_base")
        
        if [[ "$DEV_BASE" != /* ]]; then
            echo -e "${YELLOW}‚ö†Ô∏è  Path must be absolute. Using default: $DEFAULT_DEV_BASE${NC}"
            DEV_BASE="$DEFAULT_DEV_BASE"
        fi
    else
        DEV_BASE="$DEFAULT_DEV_BASE"
    fi
    
    # Create directory if it doesn't exist
    if [[ ! -d "$DEV_BASE" ]]; then
        echo ""
        read "?Directory $DEV_BASE doesn't exist. Create it? (Y/n): " create_dir
        # Default to yes (empty response or Y/y means yes)
        if [[ -z "$create_dir" ]] || [[ "$create_dir" == "y" ]] || [[ "$create_dir" == "Y" ]]; then
            if mkdir -p "$DEV_BASE" 2>/dev/null; then
                echo -e "${GREEN}‚úì Directory created: $DEV_BASE${NC}"
            else
                echo -e "${RED}‚úó Failed to create directory: $DEV_BASE${NC}"
            fi
        fi
    fi
    
    # Ask about READONLY_MODE
    echo ""
    read "?Enable directory creation? (disable READONLY_MODE) (y/N): " disable_readonly
    if [[ "$disable_readonly" == "y" ]] || [[ "$disable_readonly" == "Y" ]]; then
        READONLY_MODE=false
        echo -e "${GREEN}‚úì Directory creation enabled${NC}"
    else
        READONLY_MODE=true
        echo -e "${GRAY}Directory creation disabled${NC}"
    fi
    
    # Save configuration
    # Preserve existing INSTALL_URL if it exists
    local existing_install_url=""
    if [[ -f "$CONFIG_FILE" ]]; then
        existing_install_url=$(grep -E '^INSTALL_URL=' "$CONFIG_FILE" 2>/dev/null | sed 's/INSTALL_URL="\(.*\)".*/\1/' || echo "")
    fi
    
    mkdir -p "$CONFIG_DIR"
    cat > "$CONFIG_FILE" <<EOF
# godev configuration
# Generated on first run setup
DEV_BASE="$DEV_BASE"
READONLY_MODE=$READONLY_MODE

# Installation URL (optional)
# Default official GitHub URL and command:
# curl -fsSL https://raw.githubusercontent.com/augustose/godev/main/install.sh | zsh
# Uncomment and set to use a custom installation source:
EOF
    
    # Add INSTALL_URL if it exists, otherwise add comment
    if [[ -n "$existing_install_url" ]]; then
        echo "INSTALL_URL=\"$existing_install_url\"" >> "$CONFIG_FILE"
    else
        echo "# INSTALL_URL=\"https://raw.githubusercontent.com/augustose/godev/main\"" >> "$CONFIG_FILE"
    fi
    
    echo ""
    echo -e "${GREEN}‚úì Configuration saved!${NC}"
    echo ""
}

# Update command - check for updates and update godev
update_command() {
    echo ""
    echo -e "${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${CYAN}‚ïë${NC}  ${CYAN}üîÑ godev Update${NC}                                           ${CYAN}‚ïë${NC}"
    echo -e "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
    
    local INSTALL_DIR="${HOME}/.local/bin"
    local BIN_NAME="godev"
    local INSTALLED_SCRIPT="$INSTALL_DIR/$BIN_NAME"
    
    # Check if godev is installed
    if [[ ! -f "$INSTALLED_SCRIPT" ]]; then
        echo -e "${RED}‚úó godev is not installed at $INSTALLED_SCRIPT${NC}"
        echo ""
        echo -e "${YELLOW}Install godev first:${NC}"
        echo -e "  ${GREEN}curl -fsSL https://raw.githubusercontent.com/augustose/godev/main/install.sh | zsh${NC}"
        echo ""
        return 1
    fi
    
    # Get current installed version
    local current_version_output=$("$INSTALLED_SCRIPT" version 2>/dev/null || echo "")
    local CURRENT_VERSION=""
    if [[ -n "$current_version_output" ]]; then
        CURRENT_VERSION=$(echo "$current_version_output" | sed 's/.*version //')
    else
        # Fallback: extract from script directly
        local version=$(grep -E '^VERSION=' "$INSTALLED_SCRIPT" 2>/dev/null | sed 's/VERSION="\(.*\)".*/\1/' || echo "")
        local build=$(grep -E '^BUILD=' "$INSTALLED_SCRIPT" 2>/dev/null | sed 's/BUILD="\(.*\)".*/\1/' || echo "")
        if [[ -n "$version" ]] && [[ -n "$build" ]]; then
            CURRENT_VERSION="${version}+build.${build}"
        elif [[ -n "$version" ]]; then
            CURRENT_VERSION="$version"
        fi
    fi
    
    if [[ -z "$CURRENT_VERSION" ]]; then
        echo -e "${RED}‚úó Could not determine current version${NC}"
        return 1
    fi
    
    echo -e "${CYAN}Current version: ${BLUE}$CURRENT_VERSION${NC}"
    echo ""
    
    # Determine installation source
    local GITHUB_REPO="https://raw.githubusercontent.com/augustose/godev/main"
    local INSTALL_REPO="${INSTALL_URL:-$GITHUB_REPO}"
    local source_name="GitHub"
    if [[ -n "$INSTALL_URL" ]]; then
        source_name="configured source"
    fi
    
    local update_url="$INSTALL_REPO/godev"
    echo -e "${CYAN}Checking for updates from $source_name...${NC}"
    echo -e "${GRAY}Source:${NC} $update_url"
    
    # Download latest version to temp file
    local TEMP_DIR=$(mktemp -d)
    local TEMP_SCRIPT="$TEMP_DIR/godev"
    
    # Cleanup function for temp directory
    local cleanup_temp() {
        if [[ -n "$TEMP_DIR" ]] && [[ -d "$TEMP_DIR" ]]; then
            rm -rf "$TEMP_DIR" 2>/dev/null
        fi
    }
    
    if ! curl -fsSL "$update_url" -o "$TEMP_SCRIPT" 2>/dev/null; then
        echo -e "${RED}‚úó Failed to download latest version from $source_name${NC}"
        echo -e "${GRAY}Tried:${NC} $update_url"
        cleanup_temp
        return 1
    fi
    
    chmod +x "$TEMP_SCRIPT"
    
    # Get new version
    local new_version_output=$("$TEMP_SCRIPT" version 2>/dev/null || echo "")
    local NEW_VERSION=""
    if [[ -n "$new_version_output" ]]; then
        NEW_VERSION=$(echo "$new_version_output" | sed 's/.*version //')
    else
        # Fallback: extract from script directly
        local version=$(grep -E '^VERSION=' "$TEMP_SCRIPT" 2>/dev/null | sed 's/VERSION="\(.*\)".*/\1/' || echo "")
        local build=$(grep -E '^BUILD=' "$TEMP_SCRIPT" 2>/dev/null | sed 's/BUILD="\(.*\)".*/\1/' || echo "")
        if [[ -n "$version" ]] && [[ -n "$build" ]]; then
            NEW_VERSION="${version}+build.${build}"
        elif [[ -n "$version" ]]; then
            NEW_VERSION="$version"
        fi
    fi
    
    if [[ -z "$NEW_VERSION" ]]; then
        echo -e "${RED}‚úó Could not determine new version${NC}"
        cleanup_temp
        return 1
    fi
    
    echo -e "${CYAN}Available version: ${BLUE}$NEW_VERSION${NC}"
    echo ""
    
    # Compare versions
    if [[ "$NEW_VERSION" == "$CURRENT_VERSION" ]]; then
        echo -e "${GREEN}‚úì You already have the latest version!${NC}"
        echo ""
        cleanup_temp
        return 0
    fi
    
    echo -e "${YELLOW}An update is available!${NC}"
    echo -e "  ${GRAY}Current:${NC}  $CURRENT_VERSION"
    echo -e "  ${GREEN}New:${NC}      $NEW_VERSION"
    echo ""
    
    # Ask for confirmation
    if [[ -t 0 ]] && [[ -t 1 ]]; then
        read "?Do you want to update? (y/N): " confirm
        if [[ "$confirm" != "y" ]] && [[ "$confirm" != "Y" ]]; then
            echo -e "${GRAY}Update cancelled.${NC}"
            echo ""
            cleanup_temp
            return 0
        fi
    fi
    
    # Backup current version
    local BACKUP_SCRIPT="$INSTALLED_SCRIPT.backup"
    if cp "$INSTALLED_SCRIPT" "$BACKUP_SCRIPT" 2>/dev/null; then
        echo -e "${GRAY}‚úì Backup created: $BACKUP_SCRIPT${NC}"
    fi
    
    # Install new version
    echo -e "${CYAN}Installing update...${NC}"
    if cp "$TEMP_SCRIPT" "$INSTALLED_SCRIPT" && chmod +x "$INSTALLED_SCRIPT"; then
        echo -e "${GREEN}‚úì Update successful!${NC}"
        echo ""
        echo -e "${GREEN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
        echo -e "${GREEN}‚ïë${NC}  ${GREEN}‚úì godev updated to $NEW_VERSION${NC}                      ${GREEN}‚ïë${NC}"
        echo -e "${GREEN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
        echo ""
        cleanup_temp
        return 0
    else
        echo -e "${RED}‚úó Update failed${NC}"
        # Restore backup if available
        if [[ -f "$BACKUP_SCRIPT" ]]; then
            echo -e "${YELLOW}Restoring backup...${NC}"
            cp "$BACKUP_SCRIPT" "$INSTALLED_SCRIPT" 2>/dev/null
        fi
        cleanup_temp
        return 1
    fi
}

# Setup command - configure PATH, function wrapper, and base directory
setup_command() {
    echo ""
    echo -e "${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${CYAN}‚ïë${NC}  ${CYAN}‚öôÔ∏è  godev Setup${NC}                                            ${CYAN}‚ïë${NC}"
    echo -e "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
    
    local INSTALL_DIR="${HOME}/.local/bin"
    local script_path=$(command -v godev 2>/dev/null || echo "$INSTALL_DIR/godev")
    local made_changes=false
    
    # 1. Add PATH to .zshrc
    echo -e "${CYAN}1. Configuring PATH...${NC}"
    if [[ -f "$HOME/.zshrc" ]]; then
        if ! grep -q "$INSTALL_DIR" "$HOME/.zshrc"; then
            echo "" >> "$HOME/.zshrc"
            echo "# godev" >> "$HOME/.zshrc"
            echo "export PATH=\"\$HOME/.local/bin:\$PATH\"" >> "$HOME/.zshrc"
            echo -e "${GREEN}‚úì Added PATH to ~/.zshrc${NC}"
            made_changes=true
        else
            echo -e "${GRAY}‚úì PATH already configured in ~/.zshrc${NC}"
        fi
    else
        echo "export PATH=\"\$HOME/.local/bin:\$PATH\"" > "$HOME/.zshrc"
        echo -e "${GREEN}‚úì Created ~/.zshrc with PATH${NC}"
        made_changes=true
    fi
    
    # 2. Add function wrapper to .zshrc
    echo ""
    echo -e "${CYAN}2. Configuring function wrapper...${NC}"
    if ! grep -q "^godev()" "$HOME/.zshrc"; then
        echo "" >> "$HOME/.zshrc"
        echo "# godev function wrapper - automatically changes directory" >> "$HOME/.zshrc"
        echo "godev() {" >> "$HOME/.zshrc"
        echo "    local output=\$($script_path \"\$@\")" >> "$HOME/.zshrc"
        echo "    echo \"\$output\"" >> "$HOME/.zshrc"
        echo "    local path=\$(echo \"\$output\" | grep '^Path: ' | sed 's/^Path: //')" >> "$HOME/.zshrc"
        echo "    if [[ -n \"\$path\" ]] && [[ -d \"\$path\" ]]; then" >> "$HOME/.zshrc"
        echo "        cd \"\$path\"" >> "$HOME/.zshrc"
        echo "    fi" >> "$HOME/.zshrc"
        echo "}" >> "$HOME/.zshrc"
        echo -e "${GREEN}‚úì Function wrapper added to ~/.zshrc${NC}"
        made_changes=true
    else
        echo -e "${GRAY}‚úì Function wrapper already exists in ~/.zshrc${NC}"
    fi
    
    # 3. Configure base directory
    echo ""
    echo -e "${CYAN}3. Configuring base directory...${NC}"
    
    # Show current value
    local current_dev_base="$DEV_BASE"
    local DEFAULT_DEV_BASE="${HOME}/DEV"
    
    # Use current value as default, or system default if not set
    if [[ -z "$current_dev_base" ]] || [[ "$current_dev_base" == "${HOME}/DEV" ]]; then
        current_dev_base="$DEFAULT_DEV_BASE"
    fi
    
    echo -e "  ${GRAY}Current value:${NC} $current_dev_base"
    echo -e "  This is where godev will search for your projects"
    echo ""
    
    local setup_dev_base=""
    if prompt_input "Enter base directory for projects [$current_dev_base]: " setup_dev_base; then
        # If user provided input, use it; otherwise keep current value
        if [[ -n "$setup_dev_base" ]]; then
            setup_dev_base="${setup_dev_base/#\~/$HOME}"
            DEV_BASE=$(eval echo "$setup_dev_base")
            
            if [[ "$DEV_BASE" != /* ]]; then
                echo -e "${YELLOW}‚ö†Ô∏è  Path must be absolute. Using current value: $current_dev_base${NC}"
                DEV_BASE="$current_dev_base"
            fi
        else
            DEV_BASE="$current_dev_base"
            echo -e "${GRAY}‚úì Keeping current value${NC}"
        fi
    else
        # Non-interactive: use current value but inform the user
        DEV_BASE="$current_dev_base"
        echo -e "${YELLOW}‚ö†Ô∏è  Could not prompt (non-interactive). Using current value: $DEV_BASE${NC}"
    fi
    
    # Create directory if it doesn't exist
    if [[ ! -d "$DEV_BASE" ]]; then
        if prompt_input "Directory $DEV_BASE doesn't exist. Create it? (Y/n): " create_dir; then
            # Default to yes (empty response or Y/y means yes)
            if [[ -z "$create_dir" ]] || [[ "$create_dir" == "y" ]] || [[ "$create_dir" == "Y" ]]; then
                if mkdir -p "$DEV_BASE" 2>/dev/null; then
                    echo -e "${GREEN}‚úì Directory created: $DEV_BASE${NC}"
                else
                    echo -e "${RED}‚úó Failed to create directory: $DEV_BASE${NC}"
                fi
            else
                echo -e "${GRAY}Skipping directory creation${NC}"
            fi
        else
            # Non-interactive: try to create silently
            if mkdir -p "$DEV_BASE" 2>/dev/null; then
                echo -e "${GREEN}‚úì Directory created: $DEV_BASE${NC}"
            else
                echo -e "${YELLOW}‚ö†Ô∏è  Directory $DEV_BASE doesn't exist and could not be created in non-interactive mode${NC}"
            fi
        fi
    else
        echo -e "${GREEN}‚úì Directory exists: $DEV_BASE${NC}"
    fi
    
    # 4. Configure READONLY_MODE
    echo ""
    echo -e "${CYAN}4. Configuring directory creation...${NC}"
    
    # Show current value
    local current_readonly="$READONLY_MODE"
    # Default to true if not set
    if [[ -z "$current_readonly" ]]; then
        current_readonly=true
    fi
    
    local readonly_status="disabled"
    local readonly_default="n"
    local readonly_default_display="n (disabled)"
    if [[ "$current_readonly" == false ]]; then
        readonly_status="enabled"
        readonly_default="y"
        readonly_default_display="y (enabled)"
    fi
    
    echo -e "  ${GRAY}Current value:${NC} Directory creation is $readonly_status"
    echo ""
    
    if prompt_input "Enable directory creation? (y=enable, n=disable) [$readonly_default_display]: " disable_readonly; then
        # If user provided input, use it; otherwise use current value
        if [[ -n "$disable_readonly" ]]; then
            if [[ "$disable_readonly" == "y" ]] || [[ "$disable_readonly" == "Y" ]]; then
                READONLY_MODE=false
                echo -e "${GREEN}‚úì Directory creation enabled${NC}"
            else
                READONLY_MODE=true
                echo -e "${GRAY}Directory creation disabled${NC}"
            fi
        else
            READONLY_MODE="$current_readonly"
            echo -e "${GRAY}‚úì Using current setting: $readonly_status${NC}"
        fi
    else
        # Non-interactive: use current value but inform the user
        READONLY_MODE="$current_readonly"
        echo -e "${YELLOW}‚ö†Ô∏è  Could not prompt (non-interactive). Directory creation: $readonly_status${NC}"
    fi
    
    # Save configuration
    # Preserve existing INSTALL_URL if it exists
    local existing_install_url=""
    if [[ -f "$CONFIG_FILE" ]]; then
        existing_install_url=$(grep -E '^INSTALL_URL=' "$CONFIG_FILE" 2>/dev/null | sed 's/INSTALL_URL="\(.*\)".*/\1/' || echo "")
    fi
    
    mkdir -p "$CONFIG_DIR"
    cat > "$CONFIG_FILE" <<EOF
# godev configuration
# Generated by setup command
DEV_BASE="$DEV_BASE"
READONLY_MODE=$READONLY_MODE

# Installation URL (optional)
# Default official GitHub URL and command:
# curl -fsSL https://raw.githubusercontent.com/augustose/godev/main/install.sh | zsh
# Uncomment and set to use a custom installation source:
EOF
    
    # Add INSTALL_URL if it exists, otherwise add comment
    if [[ -n "$existing_install_url" ]]; then
        echo "INSTALL_URL=\"$existing_install_url\"" >> "$CONFIG_FILE"
    else
        echo "# INSTALL_URL=\"https://raw.githubusercontent.com/augustose/godev/main\"" >> "$CONFIG_FILE"
    fi
    
    echo ""
    echo -e "${GREEN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${GREEN}‚ïë${NC}  ${GREEN}‚úì Setup complete!${NC}                                         ${GREEN}‚ïë${NC}"
    echo -e "${GREEN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
    
    # Try to source .zshrc automatically if we made changes and we're in an interactive shell
    if [[ "$made_changes" == true ]] && [[ -t 0 ]] && [[ -t 1 ]] && [[ -n "$ZSH_VERSION" ]]; then
        echo -e "${CYAN}Applying changes to current session...${NC}"
        if source "$HOME/.zshrc" 2>/dev/null; then
            echo -e "${GREEN}‚úì Changes applied to current session${NC}"
            echo ""
        else
            echo -e "${YELLOW}‚ö†Ô∏è  Could not source ~/.zshrc automatically${NC}"
            echo -e "  ${GREEN}Run: source ~/.zshrc${NC}"
            echo ""
        fi
    elif [[ "$made_changes" == true ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Run the following to apply changes:${NC}"
        echo -e "  ${GREEN}source ~/.zshrc${NC}"
        echo ""
        echo -e "${GRAY}Or open a new terminal session${NC}"
        echo ""
    else
        echo -e "${GRAY}‚úì Configuration is already active${NC}"
        echo ""
    fi
    
    # Suggest trying godev
    echo -e "${CYAN}Try it out:${NC}"
    echo -e "  ${GREEN}godev help${NC}        # Show help"
    echo -e "  ${GREEN}godev status${NC}     # Check project status"
    echo ""
    
    # Show configuration information
    echo -e "${CYAN}Configuration information:${NC}"
    echo -e "  ${GRAY}Script location:${NC}     ${GREEN}$script_path${NC}"
    echo -e "  ${GRAY}Config file:${NC}         ${GREEN}$CONFIG_FILE${NC}"
    echo ""
    echo -e "${GRAY}You can edit the configuration file to customize:${NC}"
    echo -e "  ${GREEN}‚Ä¢ DEV_BASE${NC}          - Base directory for projects"
    echo -e "  ${GREEN}‚Ä¢ READONLY_MODE${NC}     - Enable/disable directory creation"
    echo -e "  ${GREEN}‚Ä¢ INSTALL_URL${NC}       - Custom installation source URL"
    echo ""
}

# Show help
show_help() {
    echo -e "${WHITE}godev${NC} - Multi-Folder Development Tree Demystification Tool"
    echo ""
    echo -e "${CYAN}USAGE:${NC}"
    echo "    godev <command> [options]"
    echo ""
    echo -e "${CYAN}COMMANDS:${NC}"
    echo -e "    ${GREEN}nav, n${NC} <pattern>        Navigate to project (default command)"
    echo -e "    ${GREEN}status, s${NC} [options]     Show project activity status"
    echo -e "    ${GREEN}list, l${NC}                 List all projects"
    echo -e "    ${GREEN}ai-status${NC}               Check AI development tools status"
    echo -e "    ${GREEN}setup${NC}                   Configure PATH, function wrapper, and base directory"
    echo -e "    ${GREEN}update${NC}                  Check for updates and update godev"
    echo -e "    ${GREEN}version, v${NC}              Show version"
    echo -e "    ${GREEN}help, h${NC}                 Show this help"
    echo ""
    echo -e "${CYAN}NAV OPTIONS:${NC}"
    echo "    -f, --force              Force directory creation"
    echo -e "                           ${GRAY}(Not available in readonly mode)${NC}"
    echo ""
    echo -e "${CYAN}STATUS OPTIONS:${NC}"
    echo "    -d, --dir <path>         Base directory to scan (default: ~/DEV)"
    echo "    -s, --sort <mode>        Sort mode: date|name|activity (default: date)"
    echo "    -f, --filter <days>      Show only projects active in last N days"
    echo "    -a, --all                Show all projects, including non-Git (default)"
    echo "    -g, --git-only           Show only Git repositories"
    echo ""
    echo -e "${CYAN}EXAMPLES:${NC}"
    echo "    godev nav react          # Navigate to react project"
    echo "    godev react              # Same (nav is default)"
    echo "    godev status             # Show all project statuses (default: includes non-Git)"
    echo "    godev status -f 7         # Show active in last 7 days"
    echo "    godev status -g           # Show only Git repositories"
    echo "    godev list               # List all projects"
    echo "    godev ai-status          # Check AI tools"
    echo ""
    echo -e "${CYAN}READONLY MODE:${NC}"
    echo -e "    This tool works in ${YELLOW}readonly mode${NC} by default."
    echo -e "    In readonly mode, directory creation (${GREEN}-f${NC}) is disabled."
    echo ""
    echo -e "    ${GRAY}To change readonly mode:${NC}"
    echo -e "    1. Edit the ${GREEN}godev${NC} script"
    echo -e "    2. Find: ${GREEN}READONLY_MODE=true${NC}"
    echo -e "    3. Change to: ${GREEN}READONLY_MODE=false${NC}"
    echo -e "    4. Save and restart your terminal"
}

# Main command dispatcher
main() {
    # Run first-time setup if needed (skip for help/version/update commands)
    local command="$1"
    if [[ "$command" != "help" ]] && [[ "$command" != "h" ]] && \
       [[ "$command" != "version" ]] && [[ "$command" != "v" ]] && \
       [[ "$command" != "update" ]] && [[ "$command" != "--update" ]] && \
       [[ "$command" != "-h" ]] && [[ "$command" != "--help" ]] && \
       [[ "$command" != "-v" ]] && [[ "$command" != "--version" ]]; then
        first_run_setup
    fi
    
    # Only shift if we have arguments
    if [[ $# -gt 0 ]]; then
        shift
    fi
    
    # If no command provided, show help
    if [[ -z "$command" ]]; then
        show_help
        exit 0
    fi
    
    # Check if it's a flag
    if [[ "$command" == -* ]]; then
        case "$command" in
            -v|--version)
                echo "godev version $VERSION+build.$BUILD"
                exit 0
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            --setup)
                setup_command
                exit 0
                ;;
            --update)
                update_command
                exit 0
                ;;
            *)
                # Unknown flag, treat as nav pattern
                nav_command "$command" "$@"
                return
                ;;
        esac
    fi
    
    # If command is not a known command, treat as nav pattern (default behavior)
    if [[ "$command" != "nav" ]] && [[ "$command" != "n" ]] && \
       [[ "$command" != "status" ]] && [[ "$command" != "s" ]] && \
       [[ "$command" != "list" ]] && [[ "$command" != "l" ]] && \
       [[ "$command" != "ai-status" ]] && [[ "$command" != "ai" ]] && \
       [[ "$command" != "setup" ]] && \
       [[ "$command" != "update" ]] && \
       [[ "$command" != "help" ]] && [[ "$command" != "h" ]] && \
       [[ "$command" != "version" ]] && [[ "$command" != "v" ]]; then
        # Treat as nav pattern (default behavior)
        nav_command "$command" "$@"
        return
    fi
    
    case "$command" in
        nav|n|"")
            nav_command "$@"
            ;;
        status|s|stats)
            status_command "$@"
            ;;
        list|l)
            list_command "$@"
            ;;
        ai-status|ai)
            ai_status_command "$@"
            ;;
        setup)
            setup_command
            ;;
        update)
            update_command
            ;;
        version|v)
            echo "godev version $VERSION+build.$BUILD"
            ;;
        help|h)
            show_help
            ;;
        *)
            echo -e "${RED}Unknown command: $command${NC}" >&2
            echo "Run 'godev help' for usage"
            exit 1
            ;;
    esac
}

# Navigation command (migrated from godev.sh)
nav_command() {
    local pattern=""
    local force_create=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -f|--force)
                force_create=true
                shift
                ;;
            -v|--version)
                echo "godev version $VERSION+build.$BUILD"
                return 0
                ;;
            -h|--help)
                echo "godev nav - Navigate to development project"
                echo ""
                echo "Usage: godev nav <pattern> [-f]"
                echo ""
                echo "Options:"
                echo "  <pattern>       Directory search pattern"
                echo "  -f, --force     Force directory creation (disabled in readonly mode)"
                echo "  -h, --help      Show this help"
                return 0
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}" >&2
                echo "Use 'godev nav -h' to see help"
                return 1
                ;;
            *)
                pattern="$1"
                shift
                ;;
        esac
    done
    
    # Verify that the base directory exists
    if [[ ! -d "$DEV_BASE" ]]; then
        echo -e "${RED}Error: Base directory $DEV_BASE does not exist${NC}" >&2
        echo ""
        echo "To fix this, you can:"
        echo "  1. Create the directory: ${GREEN}mkdir -p $DEV_BASE${NC}"
        echo "  2. Or set a custom base directory using the DEV_BASE variable in the script"
        echo ""
        echo "The default base directory is: ${YELLOW}~/DEV${NC}"
        echo "You can change it by editing the DEV_BASE variable in the godev script."
        return 1
    fi
    
    # Verify that a pattern was provided
    if [[ -z "$pattern" ]]; then
        echo -e "${YELLOW}Usage: godev nav <pattern> [-f]${NC}"
        echo "  -f, --force     Force directory creation"
        echo "  -h, --help      Show full help"
        return 1
    fi
    
    # Search for directories matching the pattern
    # Exclude: node_modules, .git, dist, build, vendor, .next, etc.
    local matches=()
    while IFS= read -r -d '' dir; do
        matches+=("$dir")
    done < <(find "$DEV_BASE" -maxdepth 3 -type d \
        -not -path "*/node_modules/*" \
        -not -path "*/.git/*" \
        -not -path "*/dist/*" \
        -not -path "*/build/*" \
        -not -path "*/vendor/*" \
        -not -path "*/.next/*" \
        -not -path "*/target/*" \
        -not -path "*/__pycache__/*" \
        -not -path "*/.venv/*" \
        -iname "*${pattern}*" -print0 2>/dev/null)
    
    local count=${#matches[@]}
    
    if [[ $count -eq 0 ]]; then
        # No matches found
        if [[ "$force_create" == true ]]; then
            if [[ "$READONLY_MODE" == true ]]; then
                echo -e "${YELLOW}[READONLY MODE]${NC} Would create directory: ${DEV_BASE}/${pattern}"
                echo ""
                echo "To enable directory creation, edit the godev script:"
                # Try to find where godev is installed
                local godev_path=$(command -v godev 2>/dev/null || echo "${HOME}/.local/bin/godev")
                echo -e "  ${CYAN}1.${NC} Open: ${GREEN}$godev_path${NC}"
                echo -e "  ${CYAN}2.${NC} Find the line: ${GREEN}READONLY_MODE=true${NC}"
                echo -e "  ${CYAN}3.${NC} Change it to: ${GREEN}READONLY_MODE=false${NC}"
                echo -e "  ${CYAN}4.${NC} Save the file"
                echo ""
                echo -e "  ${GRAY}Quick command: sed -i 's/READONLY_MODE=true/READONLY_MODE=false/' $godev_path${NC}"
                return 0
            else
                local new_dir="${DEV_BASE}/${pattern}"
                mkdir -p "$new_dir"
                echo -e "${GREEN}‚úì${NC} Directory created: $new_dir"
                if [[ -n "$ZSH_VERSION" ]]; then
                    # In ZSH, we can't change directory from a script
                    # User needs to source it or we output the path
                    echo "Path: $new_dir"
                    echo "Run: cd $new_dir"
                fi
                return 0
            fi
        else
            echo -e "${YELLOW}No directory found matching pattern: $pattern${NC}"
            echo "Use 'godev nav $pattern -f' to create the directory"
            return 1
        fi
    elif [[ $count -eq 1 ]]; then
        # Single match - show directory
        local target_dir="${matches[1]}"
        echo -e "${GREEN}‚Üí${NC} ${target_dir}"
        # Always output path in consistent format for function wrapper
        # Note: READONLY_MODE only prevents directory creation, not navigation
        echo "Path: $target_dir"
        # Write to temp file for function wrapper to read
        local path_file="${TMPDIR:-/tmp}/godev_selected_path_$$"
        echo "$target_dir" > "$path_file"
        return 0
    else
        # Multiple matches - show list
        # Check if we're being called from a function wrapper (stdout might be captured)
        # If so, we need to write the prompt to stderr so it's visible
        echo -e "${CYAN}Found $count directories:${NC}" >&2
        echo "" >&2
        local i=1
        for dir in "${matches[@]}"; do
            local rel_path="${dir#$DEV_BASE/}"
            echo -e "  ${GREEN}[$i]${NC} ${rel_path}" >&2
            ((i++))
        done
        echo "" >&2
        
        # Write prompt to stderr so it's visible even when output is captured
        if [[ "$READONLY_MODE" == true ]]; then
            echo -e "${GRAY}[READONLY MODE]${NC} Select a number (1-$count) to see path, or press Enter to cancel: " >&2
        else
            echo -n "Select a number (1-$count) or press Enter to cancel: " >&2
        fi
        
        # Read from /dev/tty to ensure we can read from terminal even if stdin is redirected
        read selection < /dev/tty
        
        if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -le $count ]]; then
            local target_dir="${matches[$selection]}"
            echo -e "${GREEN}‚Üí${NC} ${target_dir}"
            # Always output path in consistent format for function wrapper
            echo "Path: $target_dir"
            # Also write to temp file for function wrapper to read
            local path_file="${TMPDIR:-/tmp}/godev_selected_path_$$"
            echo "$target_dir" > "$path_file"
            return 0
        else
            echo "Cancelled" >&2
            return 1
        fi
    fi
}

# Status command (migrated from govap.sh)
status_command() {
    local SHOW_ALL=true  # Default: show all projects (including non-Git)
    local GIT_ONLY=false
    local SORT_MODE="date"
    local FILTER_DAYS=""
    local status_dev_base="$DEV_BASE"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d|--dir)
                status_dev_base="$2"
                shift 2
                ;;
            -s|--sort)
                SORT_MODE="$2"
                shift 2
                ;;
            -f|--filter)
                FILTER_DAYS="$2"
                shift 2
                ;;
            -a|--all)
                SHOW_ALL=true
                GIT_ONLY=false
                shift
                ;;
            -g|--git-only)
                SHOW_ALL=false
                GIT_ONLY=true
                shift
                ;;
            -h|--help)
                echo "godev status - Show project activity status"
                echo ""
                echo "Usage: godev status [options]"
                echo ""
                echo "Options:"
                echo "  -d, --dir <path>      Base directory to scan (default: ~/DEV)"
                echo "  -s, --sort <mode>     Sort mode: date|name|activity (default: date)"
                echo "  -f, --filter <days>   Show only projects active in last N days"
                echo "  -a, --all             Show all projects, including non-Git (default)"
                echo "  -g, --git-only        Show only Git repositories"
                echo "  -h, --help            Show this help"
                return 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}" >&2
                echo "Use 'godev status -h' for help"
                return 1
                ;;
        esac
    done
    
    # Verify that the base directory exists
    if [[ ! -d "$status_dev_base" ]]; then
        echo -e "${RED}Error: Base directory $status_dev_base does not exist${NC}" >&2
        echo ""
        echo "To fix this, you can:"
        echo "  1. Create the directory: ${GREEN}mkdir -p $status_dev_base${NC}"
        echo "  2. Or specify a different directory: ${GREEN}godev status -d /path/to/projects${NC}"
        echo "  3. Or set a custom base directory using the DEV_BASE variable in the script"
        return 1
    fi
    
    echo -e "${WHITE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${WHITE}  üîç Project Activity Status${NC}"
    echo -e "${WHITE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${GRAY}Scanning: ${status_dev_base}${NC}"
    echo ""
    
    # Collect project information
    local projects=()
    local project_count=0
    local git_count=0
    
    # Find all directories containing .git recursively
    local find_args=("$status_dev_base")
    if [[ $MAX_DEPTH -gt 0 ]]; then
        find_args+=("-maxdepth" "$MAX_DEPTH")
    fi
    find_args+=(
        "-type" "d" "-name" ".git"
        "-not" "-path" "*/node_modules/*"
        "-not" "-path" "*/dist/*"
        "-not" "-path" "*/build/*"
        "-not" "-path" "*/vendor/*"
        "-not" "-path" "*/.next/*"
        "-not" "-path" "*/target/*"
        "-not" "-path" "*/__pycache__/*"
        "-not" "-path" "*/.venv/*"
        "-print"
    )
    
    while IFS= read -r git_dir; do
        local dir=$(dirname "$git_dir")
        if [[ -d "$dir" ]]; then
            local info=$(get_project_info "$dir" "$status_dev_base" "$SHOW_ALL")
            if [[ -n "$info" ]]; then
                projects+=("$info")
                ((project_count++))
                if [[ "$info" != *"NO_GIT"* ]]; then
                    ((git_count++))
                fi
            fi
        fi
    done < <(find "${find_args[@]}" 2>/dev/null)
    
    # If SHOW_ALL is true, also include non-Git directories at first level
    if [[ "$SHOW_ALL" == true ]]; then
        for dir in "$status_dev_base"/*/; do
            if [[ -d "$dir" ]] && [[ ! -d "$dir/.git" ]]; then
                local info=$(get_project_info "$dir" "$status_dev_base" "$SHOW_ALL")
                if [[ -n "$info" ]] && [[ "$info" == *"NO_GIT"* ]]; then
                    projects+=("$info")
                    ((project_count++))
                fi
            fi
        done
    fi
    
    if [[ $project_count -eq 0 ]]; then
        echo -e "${YELLOW}No projects found in $status_dev_base${NC}"
        return 0
    fi
    
    # Filter by days if specified
    if [[ -n "$FILTER_DAYS" ]]; then
        local filtered=()
        for project in "${projects[@]}"; do
            local fields=("${(@s:|:)project}")
            local timestamp="${fields[4]}"
            local days=$(days_since_commit "$timestamp")
            if [[ $days -le $FILTER_DAYS ]]; then
                filtered+=("$project")
            fi
        done
        projects=("${filtered[@]}")
    fi
    
    # Sort projects
    case "$SORT_MODE" in
        name)
            local sorted=()
            while IFS= read -r line; do
                sorted+=("$line")
            done < <(printf '%s\n' "${projects[@]}" | sort -t'|' -k1)
            projects=("${sorted[@]}")
            ;;
        activity)
            local sorted=()
            while IFS= read -r line; do
                sorted+=("$line")
            done < <(printf '%s\n' "${projects[@]}" | sort -t'|' -k7 -rn)
            projects=("${sorted[@]}")
            ;;
        date|*)
            local sorted=()
            while IFS= read -r line; do
                sorted+=("$line")
            done < <(printf '%s\n' "${projects[@]}" | sort -t'|' -k4 -rn)
            projects=("${sorted[@]}")
            ;;
    esac
    
    # Display results
    local active_count=0
    local modified_count=0
    local ahead_count=0
    local behind_count=0
    
    printf "%-30s %-20s %-15s %-12s %s\n" \
        "PROJECT" "LAST COMMIT" "BRANCH" "STATUS" "ACTIVITY (30d)"
    echo -e "${GRAY}$(printf '%.0s‚îÄ' {1..100})${NC}"
    
    for project in "${projects[@]}"; do
        local fields=("${(@s:|:)project}")
        local name="${fields[1]}"
        local rel="${fields[2]}"
        local abs="${fields[3]}"
        local timestamp="${fields[4]}"
        local branch="${fields[5]}"
        local repo_status="${fields[6]}"
        local commits="${fields[7]}"
        local total="${fields[8]}"
        
        # Skip if no git and not showing all (git-only mode or explicit --git-only)
        if [[ "$repo_status" == "NO_GIT" ]] && [[ "$SHOW_ALL" != true ]]; then
            continue
        fi
        
        # Truncate long names
        local display_name="$name"
        if [[ ${#display_name} -gt 28 ]]; then
            display_name="${display_name:0:25}..."
        fi
        
        # Format branch
        local display_branch="$branch"
        if [[ ${#display_branch} -gt 13 ]]; then
            display_branch="${display_branch:0:10}..."
        fi
        
        # Format relative date
        local display_date="$rel"
        if [[ ${#display_date} -gt 18 ]]; then
            display_date="${display_date:0:15}..."
        fi
        
        # Status icon and color
        local status_display=$(format_status "$repo_status")
        
        # Activity indicator
        local activity_display=""
        if [[ "$commits" != "N/A" ]] && [[ "$commits" != "" ]] && [[ "$commits" =~ ^[0-9]+$ ]]; then
            if [[ $commits -gt 10 ]]; then
                activity_display="${GREEN}‚óè‚óè‚óè${NC} ($commits)"
            elif [[ $commits -gt 5 ]]; then
                activity_display="${YELLOW}‚óè‚óè‚óã${NC} ($commits)"
            elif [[ $commits -gt 0 ]]; then
                activity_display="${GRAY}‚óè‚óã‚óã${NC} ($commits)"
            else
                activity_display="${GRAY}‚óã‚óã‚óã${NC} (0)"
            fi
        else
            activity_display="${GRAY}‚óã‚óã‚óã${NC}"
        fi
        
        # Calculate real widths (without ANSI codes) for proper alignment
        local status_plain=$(strip_ansi "$status_display")
        
        local name_width=${#display_name}
        local date_width=${#display_date}
        local branch_width=${#display_branch}
        local status_width=${#status_plain}
        
        # Column widths match the header: 30, 20, 15, 12
        local name_pad=$((30 - name_width))
        local date_pad=$((20 - date_width))
        local branch_pad=$((15 - branch_width))
        local status_pad=$((12 - status_width))
        
        # Build the output line with proper padding
        local output_line=""
        output_line+="$(printf '%-30s' "$display_name")"
        output_line+="$(printf '%-20s' "$display_date")"
        output_line+="$(printf '%-15s' "$display_branch")"
        output_line+="$status_display"
        if [[ $status_pad -gt 0 ]]; then
            output_line+="$(printf '%*s' $status_pad '')"
        fi
        output_line+=" $activity_display"
        
        # Print with echo -e to interpret ANSI codes
        echo -e "$output_line"
        
        # Count statistics
        case "$repo_status" in
            clean|ahead|behind|diverged)
                ((active_count++))
                ;;
            modified)
                ((modified_count++))
                ((active_count++))
                ;;
        esac
        
        if [[ "$repo_status" == "ahead" ]] || [[ "$repo_status" == "diverged" ]]; then
            ((ahead_count++))
        fi
        if [[ "$repo_status" == "behind" ]] || [[ "$repo_status" == "diverged" ]]; then
            ((behind_count++))
        fi
    done
    
    echo ""
    echo -e "${WHITE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${GRAY}Summary:${NC}"
    echo -e "  Total projects: ${WHITE}$project_count${NC}"
    echo -e "  Git repositories: ${WHITE}$git_count${NC}"
    echo -e "  Active repos: ${GREEN}$active_count${NC}"
    if [[ $modified_count -gt 0 ]]; then
        echo -e "  Modified: ${YELLOW}$modified_count${NC}"
    fi
    if [[ $ahead_count -gt 0 ]]; then
        echo -e "  Ahead of remote: ${YELLOW}$ahead_count${NC}"
    fi
    if [[ $behind_count -gt 0 ]]; then
        echo -e "  Behind remote: ${BLUE}$behind_count${NC}"
    fi
    echo -e "${WHITE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
}

# Helper functions for status command
get_project_info() {
    local dir="$1"
    local dev_base="${2:-$DEV_BASE}"
    local show_all="${3:-false}"
    # Remove trailing slash and get relative path from DEV_BASE
    local dir_clean="${dir%/}"
    # Get relative path from DEV_BASE to show nested structure
    local dev_base_clean="${dev_base%/}"
    local project_name="${dir_clean#$dev_base_clean/}"
    # If project_name is empty or same as dir, fallback to directory name
    if [[ -z "$project_name" ]] || [[ "$project_name" == "$dir_clean" ]]; then
        project_name="${dir_clean##*/}"
    fi
    
    if [[ ! -d "$dir/.git" ]]; then
        if [[ "$show_all" == true ]]; then
            echo "$project_name|NO_GIT|N/A|N/A|N/A|N/A|N/A|N/A"
        fi
        return
    fi
    
    pushd "$dir" > /dev/null 2>&1 || return
    
    # Get last commit date (relative and absolute)
    local last_commit_relative=""
    local last_commit_absolute=""
    local last_commit_timestamp=""
    
    if git rev-parse --git-dir > /dev/null 2>&1; then
        last_commit_relative=$(git log -1 --format="%ar" 2>/dev/null)
        last_commit_absolute=$(git log -1 --format="%ci" 2>/dev/null)
        last_commit_timestamp=$(git log -1 --format="%ct" 2>/dev/null)
        
        # Get current branch
        local branch=$(git branch --show-current 2>/dev/null || echo "detached")
        
        # Get repository status
        local repo_status=""
        local git_status=$(git status --porcelain 2>/dev/null)
        local ahead=$(git status -sb 2>/dev/null | grep -o 'ahead [0-9]*' | grep -o '[0-9]*')
        local behind=$(git status -sb 2>/dev/null | grep -o 'behind [0-9]*' | grep -o '[0-9]*')
        
        if [[ -n "$git_status" ]]; then
            repo_status="modified"
        elif [[ -n "$ahead" ]] && [[ -n "$behind" ]]; then
            repo_status="diverged"
        elif [[ -n "$ahead" ]]; then
            repo_status="ahead"
        elif [[ -n "$behind" ]]; then
            repo_status="behind"
        else
            repo_status="clean"
        fi
        
        # Get commit count (last 30 days)
        local commit_count=$(git log --since="30 days ago" --oneline 2>/dev/null | wc -l | tr -d ' ')
        
        # Get total commits
        local total_commits=$(git rev-list --count HEAD 2>/dev/null || echo "0")
        
        echo "$project_name|$last_commit_relative|$last_commit_absolute|$last_commit_timestamp|$branch|$repo_status|$commit_count|$total_commits"
    fi
    
    popd > /dev/null 2>&1
}

days_since_commit() {
    local timestamp="$1"
    if [[ -z "$timestamp" ]] || [[ "$timestamp" == "N/A" ]]; then
        echo "999999"
        return
    fi
    local now=$(date +%s)
    local diff=$((now - timestamp))
    echo $((diff / 86400))
}

strip_ansi() {
    echo "$1" | sed 's/\x1b\[[0-9;]*m//g'
}

format_status() {
    local repo_status="$1"
    case "$repo_status" in
        clean)
            echo -e "${GREEN}‚úì clean${NC}"
            ;;
        modified)
            echo -e "${RED}‚óè modified${NC}"
            ;;
        ahead)
            echo -e "${YELLOW}‚Üë ahead${NC}"
            ;;
        behind)
            echo -e "${BLUE}‚Üì behind${NC}"
            ;;
        diverged)
            echo -e "${MAGENTA}‚Üï diverged${NC}"
            ;;
        NO_GIT)
            echo -e "${GRAY}‚óã no git${NC}"
            ;;
        *)
            echo -e "${GRAY}$repo_status${NC}"
            ;;
    esac
}

list_command() {
    echo -e "${YELLOW}Command 'list' is being implemented...${NC}"
    echo "This will list all projects."
}

ai_status_command() {
    echo -e "${YELLOW}Command 'ai-status' is being implemented...${NC}"
    echo "This will check AI development tools status."
}

# Run main function
main "$@"

# -----------------------------------------------------------------------------
# LICENSE (Apache 2.0)
#
# Copyright 2024 Augusto Sosa Escalada
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# -----------------------------------------------------------------------------

