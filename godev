#!/usr/bin/env zsh

# godev - Development Directory Navigation Tool
# Version: 1.0.0

VERSION="2.2.3"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/godev"
CONFIG_FILE="$CONFIG_DIR/config"

VERSION_FILE="$CONFIG_DIR/version_info"

# Colores
RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[1;33m'
BLUE=$'\033[0;34m'
MAGENTA=$'\033[0;35m'
CYAN=$'\033[0;36m'
GRAY=$'\033[0;90m'
BOLD=$'\033[1m'
NC=$'\033[0m' # No Color

# Patrones de exclusi√≥n
EXCLUDE_PATTERNS=(
    "node_modules"
    "dist"
    "build"
    "vendor"
    ".next"
    "target"
    "__pycache__"
    ".venv"
    "venv"
    ".pytest_cache"
    ".tox"
    "coverage"
    ".nuxt"
    "out"
)

# ============================================================================
# FUNCIONES DE CONFIGURACI√ìN
# ============================================================================

load_config() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo "${RED}Error: Configuration not found. Run: godev --setup${NC}" >&2
        return 1
    fi

    local env_base_dir="$GODEV_BASE_DIR"
    source "$CONFIG_FILE"
    [[ -n "$env_base_dir" ]] && GODEV_BASE_DIR="$env_base_dir"

    if [[ -z "$GODEV_BASE_DIR" ]]; then
        echo "${RED}Error: GODEV_BASE_DIR not configured${NC}" >&2
        return 1
    fi

    if [[ ! -d "$GODEV_BASE_DIR" ]]; then
        echo "${RED}Error: Base directory does not exist: $GODEV_BASE_DIR${NC}" >&2
        return 1
    fi

    return 0
}

setup_config() {
    echo "${BOLD}${CYAN}üîß godev Configuration${NC}"
    echo ""

    # Create configuration directory
    mkdir -p "$CONFIG_DIR"

    # Ask for base directory
    local default_base="$HOME/dev"
    echo -n "Projects base directory [${default_base}]: "
    read base_dir
    base_dir="${base_dir:-$default_base}"

    # Expand ~ if present
    base_dir="${base_dir/#\~/$HOME}"

    # Create directory if it doesn't exist
    if [[ ! -d "$base_dir" ]]; then
        echo -n "${YELLOW}Directory doesn't exist. Create it? (y/N): ${NC}"
        read -k 1 create
        echo
        if [[ "$create" =~ ^[yY]$ ]]; then
            mkdir -p "$base_dir"
            echo "${GREEN}‚úì Directory created${NC}"
        else
            echo "${RED}Aborted${NC}"
            return 1
        fi
    fi

    # Check for FZF
    local fzf_status="false"
    if command -v fzf &> /dev/null; then
        fzf_status="true"
        echo "${GREEN}‚úì FZF detected${NC}"
    else
        echo "${YELLOW}‚ö† FZF not detected${NC}"
        echo "  FZF is recommended for better experience:"
        echo "  macOS: brew install fzf"
        echo "  Linux: sudo apt install fzf"
    fi
    
    # Save configuration
    cat > "$CONFIG_FILE" <<EOF
# godev configuration
GODEV_BASE_DIR="$base_dir"
GODEV_FZF_ENABLED="$fzf_status"
EOF

    echo ""
    echo "${GREEN}‚úì Configuration saved to: $CONFIG_FILE${NC}"
    echo ""
    echo "${BOLD}Next steps:${NC}"
    echo "1. Make sure you have this in your ~/.zshrc:"
    echo ""
    echo "${CYAN}godev() {"
    echo "    local result"
    echo "    if [[ \"\$1\" =~ ^-- ]]; then"
    echo "        command ~/.local/bin/godev \"\$@\""
    echo "        return \$?"
    echo "    fi"
    echo "    result=\$(command ~/.local/bin/godev \"\$@\")"
    echo "    local exit_code=\$?"
    echo "    if [[ \$exit_code -eq 0 ]] && [[ -d \"\$result\" ]]; then"
    echo "        cd \"\$result\""
    echo "    else"
    echo "        echo \"\$result\""
    echo "        return \$exit_code"
    echo "    fi"
    echo "}${NC}"
    echo ""
    echo "2. Run: source ~/.zshrc"
    echo "3. Test: godev"
    
    return 0
}

# ============================================================================
# FUNCIONES DE ESCANEO
# ============================================================================

scan_projects() {
    local base_dir="$1"
    local -a projects
    
    local -A git_projects
    
    while IFS= read -r dir; do
        local dir_name="${dir##*/}"
        
        # 1. Skip hidden directories
        if [[ "$dir_name" == .* ]]; then
            continue
        fi
        
        # 2. Check exclusion patterns
        local exclude=0
        for pattern in "${EXCLUDE_PATTERNS[@]}"; do
            if [[ "$dir_name" == $pattern ]]; then
                exclude=1
                break
            fi
        done
        [[ $exclude -eq 1 ]] && continue
        
        # 3. Check if parent is a known git project
        # This prevents listing subdirectories of a git repo
        local parent_dir="${dir%/*}"
        if [[ -n "${git_projects[$parent_dir]}" ]]; then
            continue
        fi
        
        # 4. If current dir is a git repo, mark it
        if [[ -d "$dir/.git" ]]; then
            git_projects[$dir]=1
        fi
        
        projects+=("$dir")
    done < <(find "$base_dir" -mindepth 1 -maxdepth 2 -type d 2>/dev/null | sort)
    
    printf "%s\n" "${projects[@]}"
}

get_git_info() {
    local project_dir="$1"
    local -A info
    
    if [[ ! -d "$project_dir/.git" ]]; then
        info[has_git]="false"
        echo "has_git:false"
        return
    fi
    
    info[has_git]="true"
    
    # Branch
    local branch=$(git -C "$project_dir" rev-parse --abbrev-ref HEAD 2>/dev/null)
    info[branch]="${branch:-unknown}"
    
    # Status
    local git_status="clean"
    if ! git -C "$project_dir" diff-index --quiet HEAD -- 2>/dev/null; then
        git_status="modified"
    fi
    info[status]="$git_status"
    
    # √öltimo commit - calcular d√≠as transcurridos
    local last_commit_timestamp=$(git -C "$project_dir" log -1 --format="%ct" 2>/dev/null)
    local days_since="never"
    local days_since_numeric=999999
    if [[ -n "$last_commit_timestamp" ]]; then
        local now=$(date +%s)
        local diff=$((now - last_commit_timestamp))
        days_since_numeric=$((diff / 86400))

        if (( days_since_numeric == 0 )); then
            days_since="hoy"
        elif (( days_since_numeric == 1 )); then
            days_since="1 d√≠a"
        else
            days_since="${days_since_numeric} d√≠as"
        fi
    fi
    info[last_commit]="$days_since"
    info[last_commit_numeric]="$days_since_numeric"
    
    # Actividad √∫ltimos 30 d√≠as
    local activity=$(git -C "$project_dir" rev-list --count --since="30 days ago" HEAD 2>/dev/null)
    info[activity]="${activity:-0}"

    # Remote URL
    local remote_url=$(git -C "$project_dir" remote get-url origin 2>/dev/null)
    info[remote]="${remote_url:-no_remote}"
    
    echo "has_git:true|branch:${info[branch]}|status:${info[status]}|last_commit:${info[last_commit]}|last_commit_numeric:${info[last_commit_numeric]}|activity:${info[activity]}|remote:${info[remote]}"
}



# ============================================================================
# FUNCIONES DE NAVEGACI√ìN
# ============================================================================

find_project() {
    local search="$1"
    local base_dir="$2"
    
    # B√∫squeda exacta primero
    local exact_match="$base_dir/$search"
    if [[ -d "$exact_match" ]]; then
        echo "$exact_match"
        return 0
    fi
    
    # B√∫squeda fuzzy - encontrar todos los que contengan el t√©rmino
    # Nota: scan_projects devuelve rutas absolutas
    # y find_project necesita buscar en el nombre relativo
    
    local -a matches
    local clean_base="${base_dir%/}"
    
    while IFS= read -r dir; do
        # Obtener nombre relativo (puede ser "proyecto" o "cliente/proyecto")
        local rel_name="${dir#$clean_base/}"
        
        # B√∫squeda case-insensitive en el nombre relativo
        if [[ "${rel_name:l}" == *"${search:l}"* ]]; then
            matches+=("$dir")
        fi
    done < <(scan_projects "$base_dir")
    
    case ${#matches[@]} in
        0)
            # No se encontr√≥ nada
            return 1
            ;;
        1)
            # Un solo match - ir directamente
            echo "${matches[1]}"
            return 0
            ;;
        *)
            # *** MULTIPLE MATCHES - SHOW LIST AND SELECT ***
            echo "" >&2
            echo "${BOLD}${CYAN}Multiple projects found matching '${search}':${NC}" >&2
            echo "" >&2

            # Use FZF if available
            if command -v fzf &> /dev/null && [[ "$GODEV_FZF_ENABLED" == "true" ]]; then
                local selected=$(printf '%s\n' "${matches[@]}" | fzf \
                    --height 50% \
                    --reverse \
                    --border rounded \
                    --prompt "Select project > " \
                    --header "‚Üë‚Üì navigate | Enter select | Esc cancel" \
                    --preview 'echo "üìÅ {}"; echo ""; if [[ -d "{}/.git" ]]; then echo "Git Info:"; git -C {} log -1 --pretty=format:"%Cgreen%h%Creset - %s %Cblue(%ar)%Creset" 2>/dev/null || echo "No commits"; echo ""; git -C {} status -s 2>/dev/null | head -5; else echo "‚ùå Not a git repository"; fi' \
                    --preview-window right:50%:wrap \
                    --color "header:italic:cyan,prompt:bold:blue")

                if [[ -n "$selected" ]]; then
                    echo "" >&2
                    echo "${GREEN}‚úì Selected: ${selected##*/}${NC}" >&2
                    echo "$selected"
                    return 0
                else
                    echo "" >&2
                    echo "${YELLOW}Selection cancelled${NC}" >&2
                    return 1
                fi
            else
                # Without FZF - show numbered list with more information
                echo "${GRAY}‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}" >&2
                local i=1
                for match in "${matches[@]}"; do
                    local project_name="${match#$clean_base/}"
                    local git_info=""

                    # Show git info if it exists
                    if [[ -d "$match/.git" ]]; then
                        local branch=$(git -C "$match" rev-parse --abbrev-ref HEAD 2>/dev/null)
                        local status="clean"
                        if ! git -C "$match" diff-index --quiet HEAD -- 2>/dev/null; then
                            status="modified"
                        fi
                        if [[ "$status" == "modified" ]]; then
                            git_info="${GRAY}[${CYAN}$branch${GRAY} - ${YELLOW}‚óè${GRAY}]${NC}"
                        else
                            git_info="${GRAY}[${CYAN}$branch${GRAY} - ${GREEN}‚úì${GRAY}]${NC}"
                        fi
                    else
                        git_info="${GRAY}[no git]${NC}"
                    fi

                    printf "${BOLD}%2d)${NC} %-35s %b\n" "$i" "$project_name" "$git_info" >&2
                    ((i++))
                done
                echo "${GRAY}‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}" >&2
                echo "" >&2
                echo -n "${BOLD}Select a number (1-${#matches[@]}) or ${GRAY}Enter to cancel${NC}: " >&2
                read selection

                # Validate selection
                if [[ -z "$selection" ]]; then
                    echo "" >&2
                    echo "${YELLOW}Selection cancelled${NC}" >&2
                    return 1
                elif [[ "$selection" =~ ^[0-9]+$ ]] && (( selection > 0 && selection <= ${#matches[@]} )); then
                    echo "" >&2
                    echo "${GREEN}‚úì Selected: ${matches[$selection]#$clean_base/}${NC}" >&2
                    echo "${matches[$selection]}"
                    return 0
                else
                    echo "" >&2
                    echo "${RED}‚úó Invalid selection${NC}" >&2
                    return 1
                fi
            fi
            ;;
    esac
}

navigate_to_project() {
    local search="$1"
    
    load_config || return 1
    
    local project_path
    
    if [[ -z "$search" ]]; then
        # Sin argumento - men√∫ interactivo
        if command -v fzf &> /dev/null && [[ "$GODEV_FZF_ENABLED" == "true" ]]; then
            local clean_base="${GODEV_BASE_DIR%/}"
            project_path=$(scan_projects "$GODEV_BASE_DIR" | \
                # Mostrar nombre relativo en fzf
                while read item; do echo "${item#$clean_base/}"; done | \
                fzf --height 50% \
                    --reverse \
                    --border rounded \
                    --prompt "Selecciona proyecto > " \
                    --header "Todos los proyectos | ‚Üë‚Üì navega | Enter selecciona" \
                    --preview "echo 'üìÅ {}'; echo ''; full_path=\"$GODEV_BASE_DIR/{}\"; if [[ -d \"\$full_path/.git\" ]]; then echo 'Git Info:'; git -C \"\$full_path\" log -1 --pretty=format:\"%Cgreen%h%Creset - %s %Cblue(%ar)%Creset\" 2>/dev/null || echo 'Sin commits'; echo ''; git -C \"\$full_path\" status -s 2>/dev/null | head -5; else echo '‚ùå No es un repositorio git'; fi" \
                    --preview-window right:50%:wrap \
                    --color "header:italic:cyan,prompt:bold:blue")
            
            if [[ -z "$project_path" ]]; then
                echo "" >&2
                echo "${YELLOW}Selecci√≥n cancelada${NC}" >&2
                return 1
            fi
            
            # Convertir a ruta absoluta
            project_path="$GODEV_BASE_DIR/$project_path"
        else
            echo "${YELLOW}üí° Instala FZF para men√∫ interactivo: brew install fzf${NC}" >&2
            echo ""
            list_projects --simple
            return 1
        fi
    else
        project_path=$(find_project "$search" "$GODEV_BASE_DIR")
        local find_exit=$?
        
        # If find_project returned error and found nothing
        if [[ $find_exit -ne 0 ]] && [[ -z "$project_path" ]]; then
            echo "" >&2
            echo "${YELLOW}‚ö† Project '$search' not found${NC}" >&2
            echo "" >&2
            echo -n "Create new project '${BOLD}$search${NC}' in $GODEV_BASE_DIR? (${GREEN}y${NC}/${GRAY}N${NC}): " >&2
            read -k 1 create
            echo >&2
            echo "" >&2

            if [[ "$create" =~ ^[yY]$ ]]; then
                mkdir -p "$GODEV_BASE_DIR/$search"
                echo "${GREEN}‚úì Project created${NC}" >&2
                echo "$GODEV_BASE_DIR/$search"
                return 0
            else
                echo "${GRAY}Operation cancelled${NC}" >&2
                return 1
            fi
        fi
    fi
    
    echo "$project_path"
    return 0
}

# ============================================================================
# FUNCI√ìN DE LISTADO
# ============================================================================

list_projects() {
    local simple_mode="$1"
    local sort_mode="$2"  # "name" (default) or "commit"
    local show_remote="$3" # "true" or "false"
    load_config || return 1

    if [[ "$simple_mode" == "--simple" ]]; then
        local clean_base="${GODEV_BASE_DIR%/}"
        scan_projects "$GODEV_BASE_DIR" | while read dir; do
            echo "  ${dir#$clean_base/}"
        done
        return 0
    fi

    local total=0
    local with_git=0
    local modified=0
    local clean_base="${GODEV_BASE_DIR%/}"

    # Recolectar todos los proyectos con su informaci√≥n
    local -a projects_data
    while IFS= read -r project; do
        local name="${project#$clean_base/}"
        local git_raw=$(get_git_info "$project")
        local has_git=$(echo "$git_raw" | grep -o "has_git:[^|]*" | cut -d: -f2)

        local last_commit=""
        local last_commit_numeric="999999"
        local branch=""
        local project_status=""
        local activity="0"
        local remote=""

        if [[ "$has_git" == "true" ]]; then
            last_commit=$(echo "$git_raw" | grep -o "last_commit:[^|]*" | cut -d: -f2-)
            last_commit_numeric=$(echo "$git_raw" | grep -o "last_commit_numeric:[^|]*" | cut -d: -f2)
            branch=$(echo "$git_raw" | grep -o "branch:[^|]*" | cut -d: -f2)
            project_status=$(echo "$git_raw" | grep -o "status:[^|]*" | cut -d: -f2)
            activity=$(echo "$git_raw" | grep -o "activity:[^|]*" | cut -d: -f2)
            local remote=$(echo "$git_raw" | grep -o "remote:[^|]*" | cut -d: -f2-)

            ((with_git++))
            if [[ "$project_status" == "modified" ]]; then
                ((modified++))
            fi
        else
            last_commit="NO_GIT"
            last_commit="NO_GIT"
            branch="N/A"
            project_status="N/A"
            remote="N/A"
        fi

        # Formato: name|has_git|last_commit|last_commit_numeric|branch|status|activity|remote
        projects_data+=("$name|$has_git|$last_commit|$last_commit_numeric|$branch|$project_status|$activity|$remote")
        ((total++))
    done < <(scan_projects "$GODEV_BASE_DIR")

    # Ordenar seg√∫n el modo
    local -a sorted_projects
    if [[ "$sort_mode" == "commit" ]]; then
        # Ordenar por d√≠as desde √∫ltimo commit (columna 4)
        while IFS= read -r line; do
            sorted_projects+=("$line")
        done < <(printf "%s\n" "${projects_data[@]}" | sort -t'|' -k4 -n)
    else
        # Ordenar alfab√©ticamente por nombre (columna 1) - default
        while IFS= read -r line; do
            sorted_projects+=("$line")
        done < <(printf "%s\n" "${projects_data[@]}" | sort -t'|' -k1)
    fi

    # Mostrar header
    echo ""
    if [[ "$show_remote" == "true" ]]; then
        printf "${BOLD}%-40s %-20s %-15s %-12s %-15s %-40s${NC}\n" "PROJECT" "LAST COMMIT" "BRANCH" "STATUS" "ACTIVITY (30d)" "REMOTE"
        printf "%s\n" "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    else
        printf "${BOLD}%-45s %-20s %-15s %-12s %-15s${NC}\n" "PROJECT" "LAST COMMIT" "BRANCH" "STATUS" "ACTIVITY (30d)"
        printf "%s\n" "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    fi

    # Mostrar proyectos ordenados
    for project_line in "${sorted_projects[@]}"; do
        IFS='|' read -r name has_git last_commit last_commit_numeric branch project_status activity remote <<< "$project_line"

        if [[ "$show_remote" == "true" ]]; then
             printf "%-40s " "$name"
        else
             printf "%-45s " "$name"
        fi

        if [[ "$has_git" == "true" ]]; then
            printf "%-20s " "$last_commit"
            printf "${CYAN}%-15s${NC} " "$branch"

            if [[ "$project_status" == "modified" ]]; then
                printf "${YELLOW}‚óè %-10s${NC} " "$project_status"
            else
                printf "${GREEN}‚úì %-10s${NC} " "$project_status"
            fi

            # Indicador de actividad
            local bars=""
            if (( activity > 20 )); then
                bars="${GREEN}‚óè‚óè‚óè${NC}"
            elif (( activity > 5 )); then
                bars="${YELLOW}‚óè‚óè‚óã${NC}"
            elif (( activity > 0 )); then
                bars="${GRAY}‚óè‚óã‚óã${NC}"
            else
                bars="${GRAY}‚óã‚óã‚óã${NC}"
            fi

            printf "%b (%-3s)" "$bars" "$activity"

            if [[ "$show_remote" == "true" ]]; then
                 printf " %-40s\n" "$remote"
            else
                 printf "\n"
            fi
        else
            if [[ "$show_remote" == "true" ]]; then
                printf "${GRAY}%-20s %-15s %-12s %-15s %-40s${NC}\n" "NO_GIT" "N/A" "N/A" "‚óã‚óã‚óã" ""
            else
                printf "${GRAY}%-20s %-15s %-12s %-15s${NC}\n" "NO_GIT" "N/A" "N/A" "‚óã‚óã‚óã"
            fi
        fi
    done

    if [[ "$show_remote" == "true" ]]; then
        printf "%s\n" "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    else
        printf "%s\n" "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    fi
    echo ""
    echo "${BOLD}Summary:${NC}"
    echo "    Total projects: $total"
    echo "    Git repositories: $with_git"
    echo "    Modified: $modified"
    printf "%s\n" "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo ""
}

list_projects_with_pattern() {
    local search="$1"
    local show_remote="$2" # "true" or "false"
    load_config || return 1

    echo ""
    echo "${BOLD}${CYAN}Projects matching '${search}':${NC}"
    echo ""

    if [[ "$show_remote" == "true" ]]; then
        printf "${BOLD}%-40s %-20s %-15s %-12s %-15s %-40s${NC}\n" "PROJECT" "LAST COMMIT" "BRANCH" "STATUS" "ACTIVITY (30d)" "REMOTE"
        printf "%s\n" "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    else
        printf "${BOLD}%-45s %-20s %-15s %-12s %-15s${NC}\n" "PROJECT" "LAST COMMIT" "BRANCH" "STATUS" "ACTIVITY (30d)"
        printf "%s\n" "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    fi

    local total=0
    local with_git=0
    local modified=0
    local clean_base="${GODEV_BASE_DIR%/}"

    while IFS= read -r project; do
        local name="${project#$clean_base/}"

        # Filter by pattern (case-insensitive)
        if [[ ! "${name:l}" == *"${search:l}"* ]]; then
            continue
        fi

        local git_raw=$(get_git_info "$project")
        local has_git=$(echo "$git_raw" | grep -o "has_git:[^|]*" | cut -d: -f2)
        local remote=$(echo "$git_raw" | grep -o "remote:[^|]*" | cut -d: -f2-)

        if [[ "$show_remote" == "true" ]]; then
             printf "%-40s " "$name"
        else
             printf "%-45s " "$name"
        fi

        if [[ "$has_git" == "true" ]]; then
            local last_commit=$(echo "$git_raw" | grep -o "last_commit:[^|]*" | cut -d: -f2-)
            local branch=$(echo "$git_raw" | grep -o "branch:[^|]*" | cut -d: -f2)
            local project_status=$(echo "$git_raw" | grep -o "status:[^|]*" | cut -d: -f2)
            local activity=$(echo "$git_raw" | grep -o "activity:[^|]*" | cut -d: -f2)

            printf "%-20s " "$last_commit"
            printf "${CYAN}%-15s${NC} " "$branch"

            if [[ "$project_status" == "modified" ]]; then
                printf "${YELLOW}‚óè %-10s${NC} " "$project_status"
                ((modified++))
            else
                printf "${GREEN}‚úì %-10s${NC} " "$project_status"
            fi

            # Indicador de actividad
            local bars=""
            if (( activity > 20 )); then
                bars="${GREEN}‚óè‚óè‚óè${NC}"
            elif (( activity > 5 )); then
                bars="${YELLOW}‚óè‚óè‚óã${NC}"
            elif (( activity > 0 )); then
                bars="${GRAY}‚óè‚óã‚óã${NC}"
            else
                bars="${GRAY}‚óã‚óã‚óã${NC}"
            fi

            printf "%b (%-3s)" "$bars" "$activity"

            if [[ "$show_remote" == "true" ]]; then
                 printf " %-40s\n" "$remote"
            else
                 printf "\n"
            fi
            ((with_git++))
        else
            if [[ "$show_remote" == "true" ]]; then
                printf "${GRAY}%-20s %-15s %-12s %-15s %-40s${NC}\n" "NO_GIT" "N/A" "N/A" "‚óã‚óã‚óã" ""
            else
                printf "${GRAY}%-20s %-15s %-12s %-15s${NC}\n" "NO_GIT" "N/A" "N/A" "‚óã‚óã‚óã"
            fi
        fi

        ((total++))
    done < <(scan_projects "$GODEV_BASE_DIR")

    if [[ "$show_remote" == "true" ]]; then
        printf "%s\n" "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    else
        printf "%s\n" "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    fi

    if [[ $total -eq 0 ]]; then
        echo ""
        echo "${YELLOW}‚ö† No projects found matching '${search}'${NC}"
        echo ""
        return 1
    fi

    echo ""
    echo "${BOLD}Total: $total project(s)${NC}"
    echo ""
    return 0
}

# ============================================================================
# COMANDOS PRINCIPALES
# ============================================================================

show_help() {
    cat <<EOF
${BOLD}${CYAN}üöÄ godev${NC} - Demystify Your Development Tree v${VERSION}

${BOLD}Navigate 100+ projects in seconds. Make sense of complexity.${NC}

${BOLD}NAVIGATION:${NC}
    ${CYAN}godev${NC}                   ${GRAY}# Interactive menu (FZF)${NC}
    ${CYAN}godev <name>${NC}            ${GRAY}# Jump to project${NC}
    ${CYAN}godev <partial>${NC}         ${GRAY}# Search and select if multiple matches${NC}

${BOLD}LISTING:${NC}
    ${CYAN}godev --list${NC}            ${GRAY}# List ALL projects (alphabetical order)${NC}
    ${CYAN}godev -l${NC}                ${GRAY}# (short form)${NC}
    ${CYAN}godev --list --sort-by-commit${NC}  ${GRAY}# Sort by last commit (most recent first)${NC}
    ${CYAN}godev --list --remote${NC}      ${GRAY}# Show remote URL in list${NC}
    ${CYAN}godev <pattern> -l${NC}      ${GRAY}# List projects matching pattern${NC}

${BOLD}OTHER COMMANDS:${NC}
    ${CYAN}--setup${NC}                 ${GRAY}# Configure/reconfigure godev${NC}
    ${CYAN}--version, -v${NC}           ${GRAY}# Show version${NC}
    ${CYAN}--help, -h${NC}              ${GRAY}# Show this help${NC}

${BOLD}EXAMPLES:${NC}
    ${GREEN}godev${NC}                     ${GRAY}# Interactive selector for all projects${NC}
    ${GREEN}godev web${NC}                 ${GRAY}# Navigate to "web" or selector if multiple${NC}
    ${GREEN}godev my-app${NC}              ${GRAY}# Go to my-app (or create if doesn't exist)${NC}
    ${GREEN}godev -l${NC}                  ${GRAY}# List all projects (alphabetical order)${NC}
    ${GREEN}godev -l --remote${NC}         ${GRAY}# List with remote URLs${NC}
    ${GREEN}godev -l --sort-by-commit${NC} ${GRAY}# List by activity (most recent first)${NC}
    ${GREEN}godev web -l${NC}              ${GRAY}# List only projects with "web"${NC}
    ${GREEN}godev client -l${NC}           ${GRAY}# List projects for "client" folder${NC}

${BOLD}FEATURES:${NC}
    ${GREEN}‚úì${NC} Smart fuzzy search
    ${GREEN}‚úì${NC} FZF integration for better UX
    ${GREEN}‚úì${NC} Detailed Git information
    ${GREEN}‚úì${NC} Activity tracking (30 days)
    ${GREEN}‚úì${NC} Automatic multi-selection

${BOLD}CONFIGURATION:${NC}
    File: ${CYAN}${CONFIG_FILE}${NC}

${BOLD}RECOMMENDATION:${NC}
    Install FZF for premium experience: ${CYAN}brew install fzf${NC}

${BOLD}MORE INFO:${NC}
    GitHub: ${CYAN}https://github.com/augustose/godev${NC}
    Docs: ${CYAN}README.md${NC}

${GRAY}Made with ‚ù§Ô∏è  for developers who value their time${NC}

EOF
}

show_version() {
    echo "godev version ${VERSION}"
}

# ============================================================================
# MAIN
# ============================================================================

main() {
    # Verificar que estamos en ZSH
    if [[ -z "$ZSH_VERSION" ]]; then
        echo "${RED}Error: This script requires ZSH${NC}" >&2
        return 1
    fi
    
    # Parsear comandos
    case "$1" in
        --help|-h)
            show_help
            return 0
            ;;
        --version|-v)
            show_version
            return 0
            ;;
        --setup)
            setup_config
            return $?
            ;;
        --list|-l)
            # Parsear opciones de ordenamiento
            # Parsear opciones de ordenamiento
            local sort_mode="name"  # default
            local extra_arg=""
            local show_remote="false"

            # Check args 2 and 3 for flags
            for arg in "$2" "$3"; do
                if [[ "$arg" == "--simple" ]]; then
                    extra_arg="--simple"
                elif [[ "$arg" == "--sort-by-commit" ]]; then
                    sort_mode="commit"
                elif [[ "$arg" == "--remote" ]]; then
                    show_remote="true"
                fi
            done

            list_projects "$extra_arg" "$sort_mode" "$show_remote"
            return $?
            ;;
        --update)
            echo "${YELLOW}Funci√≥n de actualizaci√≥n en desarrollo${NC}"
            return 0
            ;;
        *)
            # Verificar si el segundo argumento es -l (listar con pattern)
            if [[ "$2" == "-l" ]]; then
                local show_remote="false"
                if [[ "$3" == "--remote" ]]; then
                    show_remote="true"
                fi
                list_projects_with_pattern "$1" "$show_remote"
                return $?
            fi

            # Navegaci√≥n normal
            navigate_to_project "$1"
            return $?
            ;;
    esac
}

# Ejecutar main con todos los argumentos
main "$@"
